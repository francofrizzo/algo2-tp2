\newcommand{\avlKS}{diccAVL(\ensuremath{\kappa}, \ensuremath{\sigma})} % Macro para diccAVL(k, s)

\section{M\'odulo Diccionario AVL($\kappa$, $\sigma$)}

\begin{Interfaz}
  
  \begin{paramFormales}
    \paramGeneros{$\kappa$, $\sigma$}

    \paramFuncion{
      \InterfazFuncion{$\bullet = \bullet$}{\In{k_1}{$\kappa$}, \In{k_2}{$\kappa$}}{\tipo{bool}}
      {$res \igobs (k_1 = k_2)$}
      [$\Theta(equal(k_1, k_2))$]
      [funci\'on de igualdad de $\kappa$]
    }

    \paramFuncion{
      \InterfazFuncion{$\bullet = \bullet$}{\In{k_1}{$\kappa$}, \In{k_2}{$\kappa$}}{\tipo{bool}}
      {$res \igobs (k_1 \leq k_2)$}
      [$\Theta(order(k_1, k_2))$]
      [funci\'on de comparaci\'on por orden total estricto de $\kappa$]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{k}{$\kappa$}}{$\kappa$}
      {$res \igobs k$}
      [$\Theta(copy(k))$]
      [funci\'on de copia de $\kappa$]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{s}{$\sigma$}}{$\sigma$}
      {$res \igobs s$}
      [$\Theta(copy(s))$]
      [funci\'on de copia de $\sigma$]
    }
  \end{paramFormales}

  \seExplicaCon{Diccionario($\kappa$, $\sigma$)}

  \generos{\tipo{\avlKS}}

  \Encabezado{Operaciones de diccionario}

    \InterfazFuncion{Vacio}{}{\avlKS}
    {$res \igobs$ vac\'io}
    []
    []

    \InterfazFuncion{Definir}{\Inout{d}{\avlKS}, \In{k}{$\kappa$}, \In{s}{$\sigma$}}{}
    [$d \igobs d_0$]
    {$d \igobs$ definir($k$, $s$, $d_0$)}
    []
    []

    \InterfazFuncion{Borrar}{\Inout{d}{\avlKS}, \In{k}{$\kappa$}}{}
    [$d \igobs d_0 \land$ def?($k$, $d$)]
    {$d \igobs$ borrar($k$, $d_0$)}
    []
    []

    \InterfazFuncion{\#Claves}{\In{d}{\avlKS}}{nat}
    {$res \igobs$ \#(claves($d$))}
    []
    []

    \InterfazFuncion{Definido?}{\In{d}{\avlKS}, \In{k}{$\kappa$}}{bool}
    {$res \igobs$ def?($k$, $d$)}
    []
    []

    \InterfazFuncion{Obtener}{\In{d}{\avlKS}, \In{k}{$\kappa$}}{$\sigma$}
    [def?($k$, $d$)]
    {$res \igobs$ obtener($k$, $d$)}
    []
    []

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{diccAVL($\alpha$)}[estrAVL]

    \begin{Tupla}[estrAVL]
      \tupItemNL{raiz}{puntero(nodo)}%
      \tupItemNL{cantNodos}{nat}%
    \end{Tupla}

    \begin{Tupla}[nodo]
      \tupItemNL{clave}{$\kappa$}%
      \tupItemNL{significado}{$\sigma$}%
      \tupItemNL{padre}{puntero(nodo)}%
      \tupItemNL{izq}{puntero(nodo)}%
      \tupItemNL{der}{puntero(nodo)}%
      \tupItemNL{alturaSubarbol}{nat}%
    \end{Tupla}

  \end{Estructura} 

  \Rep[estrAB][ab]{
    ($ab$.cantNodos = 0) = ($ab$.raiz = NULL) $\yluego$ \\
    ($ab$.cantNodos > 0) $\impluego$ ($ab$.cantNodos = cantHijos(\*($ab$.raiz)) + 1) $\land$ \\
    (\paratodo{nodo}{n_1, n_2})(($n_1$ $\in$ nodos($ab$) $\land$ $n_2$ $\in$ nodos($ab$)) $\impluego$ (($n_1$.izq $\neq$ $n_2$.der) $\land$ (($n_1$.izq = $n_2$.izq $\lor$ $n_1$.der = $n_2$.der) $\implies$ ($n_1 = n_2$))))
  }

  \AbsFc[estrAB]{ab($\alpha$)}[ab]{
    \IF $ab$.cantNodos = 0 THEN nil ELSE bin(Abs(plantar($ab$.raiz $\rightarrow$ izq)), $ab$.raiz $\rightarrow$ dato, Abs(plantar($ab$.raiz $\rightarrow$ der))) FI
  }

  \tadOperacion{hijos}{nodo}{conj(nodo)}{}
  \tadAxioma{hijos($n$)}{\IF $n$.izq = NULL THEN $\emptyset$ ELSE Ag(\*($n$.izq), hijos(\*($n$.izq))) FI $\cup$ \IF $n$.der = NULL THEN $\emptyset$ ELSE Ag(\*($n$.der), hijos(\*($n$.der))) FI}

  \tadOperacion{cantHijos}{nodo}{nat}{}
  \tadAxioma{cantHijos($n$)}{\#(hijos($n$))}

  \tadOperacion{nodos}{estrAB}{conj(nodo)}{}
  \tadAxioma{nodos($ab$)}{\IF $ab$.raiz = NULL THEN $\emptyset$ ELSE Ag(\*($ab$.raiz), hijos(\*($ab$.raiz))) FI}

  \tadOperacion{plantar}{puntero(nodo)}{estrAB}{}
  \tadAxioma{plantar($p$)}{$\langle p$, \IF $p$ = NULL THEN 0 ELSE cantHijos(\*($p$)) + 1 FI$\rangle$}

\end{Representacion}

\begin{Algoritmos}
  
  % Definición de funciones que se usan en el algoritmo:
  \SetKwFunction{atajoFuncion}{nombreFuncion}

  \begin{algoritmo}{nombreAlgoritmo}{parametros}
    % Crear e inicializar variables:
    \tipo{tipoVariable} $nombreVariable \as valor$ \;
    % Nota: las líneas sin comentario deben terminar en \;

    % Comentarios:
    Contenido de la linea \tcp*[h]{Comentario pegado al texto, onda C++} \com*{Comentario contra el margen}
    Contenido de la linea \com*[h]{Comentario pegado al texto} \tcp*{Comentario contra el margen, onda C++}

    % Llamada a función definida antes:
    \atajoFuncion{parametros}

    % If/then:
    \If{guarda}{
      Codigo \;
    }

    % If/then/else:
    \eIf(\com*[f]{Comentario opcional}){guarda}{
      Codigo (then) \;
    }(\com*[f]{Otro comentario opcional}){
      Codigo (else) \;
    }

    % If/then/elseif:
    \uIf{guarda}{
      Codigo (then) \;
    }\ElseIf{otra guarda}{
      Codigo (else) \;
    }

    % While:
    \While(\com*[f]{Comentario opcional}){guarda}{
      Codigo \;
    }

  \end{algoritmo}

  \SetKwFunction{fdb}{fdb}
  \SetKwFunction{raizq}{rotarAIzquierda}
  \SetKwFunction{rader}{rotarADerecha}

  \begin{algoritmo}{iRebalancearArbol}{\In{n}{puntero(nodo)}}
    \tipo{puntero(nodo)} $p \as n$ \com*{$\Theta(1)$}
    \While{$p \neq$ NULL}{ 
      \tipo{int} $fdb1 \as$ \fdb{$p$}\;
      \uIf{$fdb1 = 2$}{
        \tipo{puntero(nodo)} $q \as (p \rightarrow der)$ \;
        \tipo{int} $fdb2 \as$ \fdb{$q$} \;
        \uIf{$fdb2 = 1 \lor fdb2 = 0$}{
          \raizq{$p$} \;
          $p \as q$ \;
        }\ElseIf{$fbd2 = -1$}{
          \rader{$q$} \;
          \raizq{$p$} \;
          $p \as (q \rightarrow padre)$ \;
        }
      }\ElseIf{$fdb1 = -2$}{
        \tipo{puntero(nodo)} $q \as (p \rightarrow izq)$ \;
        \tipo{int} $fdb2 \as$ \fdb{$q$} \;
        \uIf{$fdb2 = -1 \lor fdb2 = 0$}{
          \rader{$p$} \;
          $p \as q$ \;
        }\ElseIf{$fbd2 = 1$}{
          \raizq{$q$} \;
          \rader{$p$} \;
          $p \as (q \rightarrow padre)$ \;
        }
      }
      $p \as (p \rightarrow padre)$ \;
    }
  \end{algoritmo}

\end{Algoritmos}