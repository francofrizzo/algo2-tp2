\newcommand{\diccLogKS}{diccLog(\ensuremath{\kappa}, \ensuremath{\sigma})} % Macro para diccAVL(k, s)

\section{M\'odulo Diccionario Logar\'itmico}

\Encabezado{Notas preliminares}
  En todos los casos, al indicar las complejidades de los algoritmos, las variables que se utilizan corresponden a:
  \vspace{-0.5em}\begin{itemize}
    \item $n$: Cantidad de claves definidas en el diccionario.
  \end{itemize}

\servUsados{puntero, tupla, nat}

\begin{Interfaz}
  
  \begin{paramFormales}
    \paramGeneros{$\kappa$, $\sigma$}

    \paramFuncion{
      \InterfazFuncion{$\bullet = \bullet$}{\In{k_1}{$\kappa$}, \In{k_2}{$\kappa$}}{\tipo{bool}}
      {$res \igobs (k_1 = k_2)$}
      [$\Theta(equal(k_1, k_2))$]
      [funci\'on de igualdad de $\kappa$]
    }

    \paramFuncion{
      \InterfazFuncion{$\bullet \leq \bullet$}{\In{k_1}{$\kappa$}, \In{k_2}{$\kappa$}}{\tipo{bool}}
      {$res \igobs (k_1 \leq k_2)$}
      [$\Theta(order(k_1, k_2))$]
      [funci\'on de comparaci\'on por orden total estricto de $\kappa$]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{k}{$\kappa$}}{$\kappa$}
      {$res \igobs k$}
      [$\Theta(copy(k))$]
      [funci\'on de copia de $\kappa$]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{s}{$\sigma$}}{$\sigma$}
      {$res \igobs s$}
      [$\Theta(copy(s))$]
      [funci\'on de copia de $\sigma$]
    }
  \end{paramFormales}

  \seExplicaCon{Diccionario($\kappa$, $\sigma$)}

  \generos{\tipo{\diccLogKS}}

  \Encabezado{Operaciones de diccionario}

    \InterfazFuncion{Vacio}{}{\diccLogKS}
    {$res \igobs$ vac\'io}
    [$\Theta(1)$]
    [Crea y devuelve un diccionario logar\'itmico vac\'io.]

    \InterfazFuncion{Definir}{\Inout{d}{\diccLogKS}, \In{k}{$\kappa$}, \In{s}{$\sigma$}}{}
    [$d \igobs d_0$]
    {$d \igobs$ definir($k$, $s$, $d_0$)}
    [$\Theta(\log(n) \times order(k) + copy(k) + copy(s))$]
    [Define en el diccionario la clave pasada por par\'ametro con el significado pasado por par\'ametro. En caso de que la clave ya est\'e definida, sobreescribe su significado con el nuevo.]
    [Las claves y significados se almacenan por copia.]

    \InterfazFuncion{Borrar}{\Inout{d}{\diccLogKS}, \In{k}{$\kappa$}}{}
    [$d \igobs d_0 \land$ def?($k$, $d$)]
    {$d \igobs$ borrar($k$, $d_0$)}
    [$\Theta(\log(n) \times order(k))$]
    [Elimina del diccionario la clave pasada por par\'ametro.]

    \InterfazFuncion{CantClaves}{\In{d}{\diccLogKS}}{nat}
    {$res \igobs$ \#(claves($d$))}
    [$\Theta(1)$]
    [Devuelve la cantidad de claves del diccionario.]

    \InterfazFuncion{Definido?}{\In{d}{\diccLogKS}, \In{k}{$\kappa$}}{bool}
    {$res \igobs$ def?($k$, $d$)}
    [$\Theta(\log(n) \times order(k))$]
    [Devuelve true si y solo si la clave pasada por par\'ametro est\'a definida en el diccionario.]

    \InterfazFuncion{Obtener}{\In{d}{\diccLogKS}, \In{k}{$\kappa$}}{$\sigma$}
    [def?($k$, $d$)]
    {alias($res \igobs$ obtener($k$, $d$))}
    [$\Theta(\log(n) \times order(k))$]
    [Devuelve el significado con el que la clave pasada por par\'ametro est\'a definida en el diccionario.]
    [El significado se pasa por referencia. Modificarlo implica cambiarlo en la estructura interna del diccionario.]

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{\diccLogKS}[estrAVL]
    \hspace*{3mm}donde \TipoVariable{estrAVL} es \TipoVariable{ab(tupla($clave:$ $\kappa$, $significado:$ $\sigma$, $altSubarbol:$ nat))}
  \end{Estructura} 

  \Rep[estrAVL][a]{
    $\neg$ nil?($a$) $\implies$ ( \\
    \hspace*{3mm}(nil?(izq($a$)) $\oluego$ (raiz(izq($a$)) $\neq$ raiz($a$) $\land$ raiz(izq($a$)) $\leq$ raiz($a$))) $\land$ \\
    \hspace*{3mm}(nil?(der($a$)) $\oluego$ (raiz(der($a$)) $\neq$ raiz($a$) $\land$ raiz(der($a$)) $\geq$ raiz($a$))) $\land$ \\
    \hspace*{3mm}raiz($a$).altSubarbol = altura($a$) $\land$ \\
    \hspace*{3mm}m\'ax(altura(izq($a$)), altura(der($a$))) $-$ m\'in(altura(izq($a$)), altura(der($a$))) $\leq$ 1 $\land$ \\
    \hspace*{3mm}Rep(izq($a$)) $\land$ Rep(der($a$))
    \\ )
  }
  ~
  \AbsFc[estrAVL]{dicc($\kappa$, $\sigma$))}[a]{
    \IF nil?($a$) THEN vac\'io ELSE definir(raiz($a$).clave, raiz($a$).significado, unir(Abs(izq($a$)), Abs(der($a$)))) FI
  }
  ~
  \tadOperacion{unir}{dicc($\kappa$, $\sigma$), dicc($\kappa$, $\sigma$)}{dicc($\kappa$, $\sigma$)}{}
  \tadAxioma{
    unir($d_1$, $d_2$)}{\IF vac\'io($d_2$) THEN $d_1$ ELSE definir( \\
    \hspace*{3mm}dameUno(claves($d_2$)), \\
    \hspace*{3mm}obtener(dameUno(claves($d_2$)), $d_2$), \\
    \hspace*{3mm}unir($d_1$, borrar(dameUno(claves($d_2$)), $d_2$)) \\
    ) FI
  }

\end{Representacion}

\begin{Algoritmos}

  \SetKwFunction{fdb}{FactorDeBalanceo}
  \SetKwFunction{raizq}{RotarAIzquierda}
  \SetKwFunction{rader}{RotarADerecha}
  \SetKwFunction{buscar}{Buscar}
  \SetKwFunction{rebalancear}{RebalancearArbol}
  \SetKwFunction{recalcAlt}{RecalcularAltura}
  % \SetKwFunction{recalcAlts}{RecalcularAlturas}

  \begin{algoritmo}{iVacio}{}{estrAVL}
    $res \gets$ \nil{} \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iDefinir}{\In{k}{$\kappa$}, \In{s}{$\sigma$}, \Inout{a}{estrAVL}}{}
    \tipo{estrAVL} $padre$ \;
    \tipo{estrAVL} $lugar \gets$ \buscar{$a$, $k$, $padre$} \com*{$\Theta(\log(n) \times order(k))$}
    \eIf(\com*[f]{$\Theta(1)$}){$\neg$ \esNil{$lugar$}}{
      \raiz{$lugar$}.$signficado \gets$ \copiar{$s$} \com*{$\Theta(copy(s))$}
    }{
      \tipo{estrAVL} $nuevo \gets \new$ \bin{\nil{}, $\langle$\copiar{k}, \copiar{s}$, 1 \rangle$, \nil{}} \tcp*[h]{Reservamos memoria para el nuevo nodo} \com*{$\Theta(copy(k) + copy(s))$}
      \eIf(\com*[f]{$\Theta(order(k))$}){$k \leq $\raiz{$padre$}$.clave$}{
        $padre \gets$ \bin{$nuevo$, \raiz{$padre$}, \der{$padre$}} \com*{$\Theta(1)$}
      }{
        $padre \gets$ \bin{\izq{$padre$}, \raiz{$padre$}, $nuevo$} \com*{$\Theta(1)$}
      }
      \rebalancear($padre$) \com*{$\Theta(\log(n))$}
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n) \times order(k) + copy(k) + copy(s))$} % Complejidad
  {La funci\'on tiene llamadas a funciones con complejidad $\Theta(\log(n) \times order(k))$ y $\Theta(copy(k) + copy(s))$.} % Justificacíón

  \begin{algoritmo}{iObtener}{\In{a}{estrAVL}, \In{k}{$\kappa$}}{$\sigma$}
    \tipo{puntero(nodo)} $padre \gets \NULL$ \com*{$\Theta(1)$}
    \tipo{puntero(nodo)} $lugar \gets$ \buscar{$a$, $k$, $padre$} \com*{$\Theta(\log(n) \times order(k))$}
    $res \gets (lugar \to significado)$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n) \times order(k))$} % Complejidad
  {La funci\'on tiene llamadas a funciones con complejidad $\Theta(\log(n) \times order(k)$ y $\Theta(copy(k) + copy(s))$.} % Justificacíón

  \begin{algoritmo}{iCantClaves}{\In{a}{estrAVL}}{nat}
    $res \gets$ \cantNodos{$a$} \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iDefinido?}{\In{a}{estrAVL}, \In{k}{$\kappa$}}{bool}
    \tipo{puntero(nodo)} $padre \gets \NULL$ \com*{$\Theta(1)$}
    \tipo{puntero(nodo)} $lugar \gets$ \buscar{$a$, $k$, $padre$} \com*{$\Theta(\log(n) \times order(k))$}
    $res \gets (lugar \neq \NULL)$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n) \times order(k))$} % Complejidad
  {$\Theta(1) + \Theta(\log(n) \times order(k)) + \Theta(1) = \Theta(\log(n) \times order(k)) + \Theta(1)$} % Justificación

  \begin{algoritmo}{iBorrar}{\Inout{a}{estrAVL}, \In{k}{$\kappa$}}{}
    \tipo{puntero(nodo)} $padre \gets \NULL$ \com*{$\Theta(1)$}
    \tipo{puntero(nodo)} $lugar \gets$ \buscar{$a$, $k$, $padre$} \com*{$\Theta(\log(n) \times order(k))$}
    \uIf(\com*[f]{$\Theta(1)$}){$lugar \to izq = \NULL \land lugar \to der = \NULL$}{
      \eIf(\com*[f]{$\Theta(1)$}){$padre \neq \NULL$}{
        \eIf(\com*[f]{$\Theta(1)$}){$padre \to izq = lugar$}{
          $(padre \to izq) \gets \NULL$ \com*{$\Theta(1)$}
        }{
          $(padre \to der) \gets \NULL$ \com*{$\Theta(1)$}
        }
        % \recalcAlts{$padre$} \;
        \rebalancear{$padre$} \com*{$\Theta(\log(n))$}
      }{
        $a.raiz = \NULL$ \com*{$\Theta(1)$}
      }
    }\uElseIf(\com*[f]{$\Theta(1)$}){$lugar \to der = \NULL$}{
      $(lugar \to izq \to padre) \gets padre$ \com*{$\Theta(1)$}
      \eIf(\com*[f]{$\Theta(1)$}){$padre \neq \NULL$}{
        \eIf(\com*[f]{$\Theta(1)$}){$padre \to izq = lugar$}{
          $(padre \to izq) \gets (lugar \to izq)$ \com*{$\Theta(1)$}
        }{
          $(padre \to der) \gets (lugar \to izq)$ \com*{$\Theta(1)$}
        }
        % \recalcAlts{$padre$} \;
        \rebalancear{$padre$} \com*{$\Theta(\log(n))$}
      }{
        $a.raiz \gets lugar \to izq$ \com*{$\Theta(1)$}
      }
    }\uElseIf(\com*[f]{$\Theta(1)$}){$lugar \to izq = \NULL$}{
      $(lugar \to der \to padre) \gets padre$ \com*{$\Theta(1)$}
      \eIf(\com*[f]{$\Theta(1)$}){$padre \neq \NULL$}{
        \eIf(\com*[f]{$\Theta(1)$}){$padre \to izq = lugar$}{
          $(padre \to izq) \gets (lugar \to der)$ \com*{$\Theta(1)$}
        }{
          $(padre \to der) \gets (lugar \to der)$ \com*{$\Theta(1)$}
        }
        % \recalcAlts{$padre$} \;
        \rebalancear{$padre$} \com*{$\Theta(\log(n))$}
      }{
        $a.raiz \gets lugar \to izq$ \com*{$\Theta(1)$}
      }
    }
  \end{algoritmo}

  \begin{contAlgoritmo}{iBorrar}
    \Else{
      \tipo{puntero(nodo)} $reemplazo \gets (lugar \to der)$ \com*{$\Theta(1)$}
      \eIf(\com*[f]{$\Theta(1)$}){$(reemplazo \to izq = \NULL)$}{
        \eIf(\com*[f]{$\Theta(1)$}){$padre \neq \NULL$}{
          \eIf(\com*[f]{$\Theta(1)$}){$(padre \to izq) = lugar$}{
            $(padre \to izq) \gets reemplazo$ \com*{$\Theta(1)$}
          }{
            $(padre \to der) \gets reemplazo$ \com*{$\Theta(1)$}
          }
        }{
          $a.raiz \gets reemplazo$ \com*{$\Theta(1)$}
        }
        $(reemplazo \to padre) \gets padre$ \com*{$\Theta(1)$}
        $(reemplazo \to izq) \gets lugar \to izq$ \com*{$\Theta(1)$}
        $(lugar \to izq \to padre) \gets reemplazo$ \com*{$\Theta(1)$}
        % \recalcAlts{$reemplazo$} \;
        \rebalancear{$reemplazo$} \com*{$\Theta(\log(n))$}
      }{
        \While(\com*[f]{$\Theta(\log(n))$ iteraciones}){$(reemplazo \to izq) \neq \NULL$}{
          $reemplazo \gets (reemplazo \to izq)$ \com*{$\Theta(1)$}
        }
        \tipo{puntero(nodo)} $padreReemplazo \gets (reemplazo \to padre)$ \com*{$\Theta(1)$}
        \eIf(\com*[f]{$\Theta(1)$}){$padre \neq \NULL$}{
          \eIf(\com*[f]{$\Theta(1)$}){$padre \to izq = lugar$}{
            $(padre \to izq) \gets reemplazo$ \com*{$\Theta(1)$}
          }{
            $(padre \to der) \gets reemplazo$ \com*{$\Theta(1)$}
          }
        }{
          $a.raiz \gets reemplazo$ \com*{$\Theta(1)$}
        }
        $(reemplazo \to padre) \gets padre$ \com*{$\Theta(1)$}
        $(reemplazo \to izq) \gets lugar \to izq$ \com*{$\Theta(1)$}
        $(lugar \to izq \to padre) \gets reemplazo$ \com*{$\Theta(1)$}
        $(padreReemplazo \to izq) \gets (reemplazo \to der)$ \com*{$\Theta(1)$}
        \If(\com*[f]{$\Theta(1)$}){$(reemplazo \to der) \neq \NULL$}{
          $(reemplazo \to der \to padre) \gets padreReemplazo$ \com*{$\Theta(1)$}
        }
        $(reemplazo \to der) \gets (lugar \to der)$ \com*{$\Theta(1)$}
        $(lugar \to der \to padre) \gets reemplazo$ \com*{$\Theta(1)$}
        % \recalcAlts{$reemplazo$} \;
        \rebalancear{$reemplazo$} \com*{$\Theta(\log(n))$}
      }
    }
    \delete{$lugar$} \tcp*[h]{Liberamos la memoria ocupada por el nodo eliminado.} \com*{$\Theta(1)$}
  \end{contAlgoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n) \times order(k))$} % Complejidad
  {El algoritmo tiene una llamada a funci\'on con complejidad $\Theta(\log(n) \times order(k))$, y luego presenta varios casos, pero en todos ellos las funciones llamadas son $O(\log(n))$.} % Justificación

  \begin{algoritmo}{iBuscar}{\In{a}{estrAVL}, \In{k}{$\kappa$}, \Out{padre}{estrAVL}}{puntero(estrAVL)}
    $padre \gets$ \nil{} \com*{$\Theta(1)$}
    $actual \gets a$ \com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(\log(n))$ iteraciones}){$\neg$ \esNil{$actual$} $\yluego ($\raiz{$actual$}.$clave$ $ \neq k)$}{
      $padre \gets actual$ \com*{$\Theta(1)$}
      \eIf(\com*[f]{$\Theta(order(k))$}){$k \leq$ \raiz{$actual$}.$clave$}{
        $actual \gets$ \izq{$actual$} \com*{$\Theta(1)$}
      }{
        $actual \gets$ \der{$actual$} \com*{$\Theta(1)$}
      }
    }
    $res \gets actual$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe el \'arbol AVL sobre el que est\'a representado el diccionario y una clave por par\'ametro. Si la clave est\'a definida, devuelve el sub\'arbol que tiene a dicha clave en su ra\'iz, y coloca en el par\'ametro de out $padre$ el sub\'arbol del cual dicha clave es hija inmediata. En caso contrario, devuelve un \'arbol vac\'io y coloca en el par\'ametro de out $padre$ el sub\'arbol \'arbol del cual la clave deber\'ia ser hija inmediata, si estuviera definida.} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n) \times order(k))$} % Complejidad
  {El algoritmo presenta un ciclo que se repite $\Theta(\log(n))$ veces, y en cada una de ellas se realiza una llamada a funci\'on con complejidad $\Theta(order(k))$.} % Justificación

  % \begin{algoritmo}{iRecalcularAlturas}{\In{n}{puntero(nodo)}}{}
  %   \tipo{puntero(nodo)} $p \gets n$ \com*{$\Theta(1)$}
  %   \While(\com*[f]{$\Theta(\log(n))$ iteraciones}){$p \neq \NULL$}{
  %     \uIf{$p \to izq \neq \NULL \land p \to der \neq \NULL$}{
  %       $(p \to altSubarbol) \gets 1$ + \maximo{$p \to izq \to altSubarbol$, $p \to der \to altSubarbol$} \com*{$\Theta(1)$}
  %     }\uElseIf{$p \to izq \neq \NULL$}{
  %       $(p \to altSubarbol) \gets 1 + (p \to izq \to altSubarbol)$ \com*{$\Theta(1)$}
  %     }\uElseIf{$p \to der \neq \NULL$}{
  %       $(p \to altSubarbol) \gets 1 + (p \to der \to altSubarbol)$ \com*{$\Theta(1)$}
  %     }\Else{
  %       $(p \to altSubarbol) \gets 1$ \com*{$\Theta(1)$}
  %     }
  %     $p \gets (p \to padre)$ \com*{$\Theta(1)$}
  %   }
  % \end{algoritmo}
  % \datosAlgoritmo{} % Descripción
  % {} % Pre
  % {} % Post
  % {$\Theta(\log(n))$} % Complejidad
  % {} % Justificación

  \begin{algoritmo}{iRecalcularAltura}{\In{n}{puntero(nodo)}}{}
    \uIf(\com*[f]{$\Theta(1)$}){$n \to izq \neq \NULL \land n \to der \neq \NULL$}{
      $(n \to altSubarbol) \gets 1$ + \maximo{$n \to izq \to altSubarbol$, $n \to der \to altSubarbol$} \com*{$\Theta(1)$}
    }\uElseIf(\com*[f]{$\Theta(1)$}){$n \to izq \neq \NULL$}{
      $(n \to altSubarbol) \gets 1 + (n \to izq \to altSubarbol)$ \com*{$\Theta(1)$}
    }\uElseIf(\com*[f]{$\Theta(1)$}){$n \to der \neq \NULL$}{
      $(n \to altSubarbol) \gets 1 + (n \to der \to altSubarbol)$ \com*{$\Theta(1)$}
    }\Else{
      $(n \to altSubarbol) \gets 1$ \com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe un puntero a un nodo del \'arbol y recalcula el valor de su campo $altSubarbol$ en funci\'on a los datos que sus nodos hijos poseen en este campo.} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {El algoritmo presenta varios casos, y todos ellos realizan realizan operaciones con complejidad $\Theta(1)$.} % Justificación

  \begin{algoritmo}{iFactorDeBalanceo}{\In{n}{puntero(nodo)}}{int}
    \tipo{int} $altIzq \gets n \to izq = \NULL$ ? 0 : $n \to izq \to altSubarbol$ \com*{$\Theta(1)$}
    \tipo{int} $altDer \gets n \to der = \NULL$ ? 0 : $n \to izq \to altSubarbol$ \com*{$\Theta(1)$}
    $res \gets altDer - altIzq$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe un puntero a un nodo del \'arbol y calcula su factor de balanceo.} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {$\Theta(1) + \Theta(1) + \Theta(1) = \Theta(1)$} % Justificación

  \begin{algoritmo}{iRotarAIzquierda}{\In{n}{puntero(nodo)}}{}
    \If(\com*[f]{$\Theta(1)$}){$n.padre \neq \NULL$}{
      \eIf(\com*[f]{$\Theta(1)$}){$n.padre \to izq = n$}{
        $(n \to padre \to izq) \gets n \to der$ \com*{$\Theta(1)$}
      }{
        $(n \to padre \to der) \gets n \to der$ \com*{$\Theta(1)$}
      }
    }
    $(n \to der \to padre) \gets n \to padre$ \com*{$\Theta(1)$} 
    $n \to padre \gets n \to der$ \com*{$\Theta(1)$}
    $n \to der \gets (n \to der \to izq)$ \com*{$\Theta(1)$}
    \If(\com*[f]{$\Theta(1)$}){$n \to der \neq \NULL$}{
      $(n \to der \to padre) \gets n$ \com*{$\Theta(1)$}
    }
    $(n \to padre \to izq) \gets n$ \com*{$\Theta(1)$}
    \recalcAlt{$n$} \com*{$\Theta(1)$}
    \recalcAlt{$n \to padre$} \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe un puntero a un nodo del \'arbol y realiza una rotaci\'on a izquierda de dicho nodo. !`Ojo, rompe el invariante de representaci\'on! (Los campos $altSubarbol$ de los nodos superiores quedan inconsistentes).} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {Todas las operaciones que realiza el algoritmo tienen complejidad $\Theta(1)$.} % Justificación

  \begin{algoritmo}{iRotarADerecha}{\In{n}{puntero(nodo)}}{}
    \If(\com*[f]{$\Theta(1)$}){$n \to padre \neq \NULL$}{
      \eIf(\com*[f]{$\Theta(1)$}){$n \to padre \to izq = n$}{
        $(n \to padre \to izq) \gets n \to izq$ \com*{$\Theta(1)$}
      }{
        $(n \to padre \to der) \gets n \to izq$ \com*{$\Theta(1)$}
      }
    }
    $(n \to izq \to padre) \gets n \to padre$ \com*{$\Theta(1)$} 
    $n \to padre \gets n \to izq$ \com*{$\Theta(1)$}
    $n \to izq \gets (n \to izq \to der)$ \com*{$\Theta(1)$}
    \If(\com*[f]{$\Theta(1)$}){$n \to izq \neq \NULL$}{
      $(n \to izq \to padre) \gets n$ \com*{$\Theta(1)$}
    }
    $(n \to padre \to der) \gets n$ \com*{$\Theta(1)$}
    \recalcAlt{$n$} \com*{$\Theta(1)$}
    \recalcAlt{$n \to padre$} \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe un puntero a un nodo del \'arbol y realiza una rotaci\'on a derecha de dicho nodo. !`Ojo, rompe el invariante de representaci\'on! (Los campos $altSubarbol$ de los nodos superiores quedan inconsistentes).} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {Todas las operaciones que realiza el algoritmo tienen complejidad $\Theta(1)$.} % Justificación

  \begin{algoritmo}{iRebalancearArbol}{\In{n}{puntero(nodo)}}{}
    \tipo{puntero(nodo)} $p \gets n$ \com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(\log(n))$ iteraciones}){$p \neq \NULL$}{ 
      \recalcAlt{$p$} \com*{$\Theta(1)$}
      \tipo{int} $fdb1 \gets$ \fdb{$p$} \com*{$\Theta(1)$}
      \uIf(\com*[f]{$\Theta(1)$}){$fdb1 = 2$}{
        \tipo{puntero(nodo)} $q \gets (p \to der)$ \com*{$\Theta(1)$}
        \tipo{int} $fdb2 \gets$ \fdb{$q$} \com*{$\Theta(1)$}
        \uIf(\com*[f]{$\Theta(1)$}){$fdb2 = 1 \lor fdb2 = 0$}{
          \raizq{$p$} \com*{$\Theta(1)$}
          $p \gets q$ \com*{$\Theta(1)$}
        }\ElseIf(\com*[f]{$\Theta(1)$}){$fdb2 = -1$}{
          \rader{$q$} \com*{$\Theta(1)$}
          \raizq{$p$} \com*{$\Theta(1)$}
          $p \gets (q \to padre)$ \com*{$\Theta(1)$}
        }
      }\ElseIf{$fdb1 = -2$}{
        \tipo{puntero(nodo)} $q \gets (p \to izq)$ \com*{$\Theta(1)$}
        \tipo{int} $fdb2 \gets$ \fdb{$q$} \com*{$\Theta(1)$}
        \uIf(\com*[f]{$\Theta(1)$}){$fdb2 = -1 \lor fdb2 = 0$}{
          \rader{$p$} \com*{$\Theta(1)$}
          $p \gets q$ \com*{$\Theta(1)$}
        }\ElseIf(\com*[f]{$\Theta(1)$}){$fdb2 = 1$}{
          \raizq{$q$} \com*{$\Theta(1)$}
          \rader{$p$} \com*{$\Theta(1)$}
          $p \gets (q \to padre)$ \com*{$\Theta(1)$}
        }
      }
      $p \gets (p \to padre)$ \com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe un puntero a un nodo del \'arbol y restaura el invariante de representaci\'on en la rama ascendente a partir de dicho nodo, realizando las rotaciones necesarias para rebalancear el \'arbol.} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n))$} % Complejidad
  {El algoritmo presenta un ciclo que se ejecuta $\Theta(\log(n))$ veces, y en cada una de ellas se realizan operaciones con complejidad $\Theta(1)$.} % Justificación

\end{Algoritmos}
