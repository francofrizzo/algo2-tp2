\newcommand{\avlKS}{diccAVL(\ensuremath{\kappa}, \ensuremath{\sigma})} % Macro para diccAVL(k, s)

\section{M\'odulo Diccionario AVL}

\Encabezado{Notas preliminares}
  En todos los casos, al indicar las complejidades de los algoritmos, las variables que se utilizan corresponden a:
  \vspace{-0.5em}\begin{itemize}
    \item $n$: Cantidad de claves definidas en el diccionario.
  \end{itemize}

\begin{Interfaz}
  
  \begin{paramFormales}
    \paramGeneros{$\kappa$, $\sigma$}

    \paramFuncion{
      \InterfazFuncion{$\bullet = \bullet$}{\In{k_1}{$\kappa$}, \In{k_2}{$\kappa$}}{\tipo{bool}}
      {$res \igobs (k_1 = k_2)$}
      [$\Theta(equal(k_1, k_2))$]
      [funci\'on de igualdad de $\kappa$]
    }

    \paramFuncion{
      \InterfazFuncion{$\bullet \leq \bullet$}{\In{k_1}{$\kappa$}, \In{k_2}{$\kappa$}}{\tipo{bool}}
      {$res \igobs (k_1 \leq k_2)$}
      [$\Theta(order(k_1, k_2))$]
      [funci\'on de comparaci\'on por orden total estricto de $\kappa$]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{k}{$\kappa$}}{$\kappa$}
      {$res \igobs k$}
      [$\Theta(copy(k))$]
      [funci\'on de copia de $\kappa$]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{s}{$\sigma$}}{$\sigma$}
      {$res \igobs s$}
      [$\Theta(copy(s))$]
      [funci\'on de copia de $\sigma$]
    }
  \end{paramFormales}

  \seExplicaCon{Diccionario($\kappa$, $\sigma$)}

  \generos{\tipo{\avlKS}}

  \Encabezado{Operaciones de diccionario}

    \InterfazFuncion{Vacio}{}{\avlKS}
    {$res \igobs$ vac\'io}
    [$\Theta(1)$]
    [Crea y devuelve un diccionario AVL vac\'io.]

    \InterfazFuncion{Definir}{\Inout{d}{\avlKS}, \In{k}{$\kappa$}, \In{s}{$\sigma$}}{}
    [$d \igobs d_0$]
    {$d \igobs$ definir($k$, $s$, $d_0$)}
    [$\Theta(\log(n) \times order(k) + copy(k) + copy(s))$]
    [Define en el diccionario la clave pasada por par\'ametro con el significado pasado por par\'ametro. En caso de que la clave ya est\'e definida, sobreescribe su significado con el nuevo.]
    [Las claves y significados se almacenan por copia.]

    \InterfazFuncion{Borrar}{\Inout{d}{\avlKS}, \In{k}{$\kappa$}}{}
    [$d \igobs d_0 \land$ def?($k$, $d$)]
    {$d \igobs$ borrar($k$, $d_0$)}
    [$\Theta(\log(n) \times order(k))$]
    [Elimina del diccionario la clave pasada por par\'ametro.]

    \InterfazFuncion{\#Claves}{\In{d}{\avlKS}}{nat}
    {$res \igobs$ \#(claves($d$))}
    [$\Theta(1)$]
    [Devuelve la cantidad de claves del diccionario.]

    \InterfazFuncion{Definido?}{\In{d}{\avlKS}, \In{k}{$\kappa$}}{bool}
    {$res \igobs$ def?($k$, $d$)}
    [$\Theta(\log(n) \times order(k))$]
    [Devuelve true si y solo si la clave pasada por par\'ametro est\'a definida en el diccionario.]

    \InterfazFuncion{Obtener}{\In{d}{\avlKS}, \In{k}{$\kappa$}}{$\sigma$}
    [def?($k$, $d$)]
    {alias($res \igobs$ obtener($k$, $d$))}
    [$\Theta(\log(n) \times order(k))$]
    [Devuelve el significado con el que la clave pasada por par\'ametro est\'a definida en el diccionario.]
    [El significado se pasa por referencia. Modificarlo implica cambiarlo en la estructura interna del diccionario.]

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{diccAVL($\kappa$, $\sigma$)}[estrAVL]

    \begin{Tupla}[estrAVL]
      \tupItemNL{raiz}{puntero(nodo)}%
      \tupItemNL{cantNodos}{nat}%
    \end{Tupla}

    \begin{Tupla}[nodo]
      \tupItemNL{clave}{$\kappa$}%
      \tupItemNL{significado}{$\sigma$}%
      \tupItemNL{padre}{puntero(nodo)}%
      \tupItemNL{izq}{puntero(nodo)}%
      \tupItemNL{der}{puntero(nodo)}%
      \tupItemNL{altSubarbol}{nat}%
    \end{Tupla}

  \end{Estructura} 

  \Rep[estrAVL][e]{
    $e.cantNodos$ = \#(nodos($e$)) $\land$ \\
    \#(claves($e$)) = \#(nodos($e$)) $\land$ \\
    $(\paratodo{nodo}{n})$ ($n$ $\in$ nodos($e$) $\impluego$ (\\
    $n.altSubarbol$ = altura(sub\'arbol($\&n$)) $\land$ \\
    m\'ax(altura(sub\'arbol($n.izq$)), altura(sub\'arbol($n.der$))) $-$ \\
    m\'in(altura(sub\'arbol($n.izq$)), altura(sub\'arbol($n.der$))) $\leq 1 \land$ \\
    $(\paratodo{nodo}{n'})$ (($n' \in$ nodos(sub\'arbol($n$))) $\implies$ ($n' \in$ nodos(sub\'arbol($n.der$)) $\Leftrightarrow$ $\neg (n'.clave \leq n.clave)$)) $\land$ \\
    $*(n.izq) \neq *(n.der)$ $\land$ $(n.padre = \NULL \Leftrightarrow \&n = e.raiz) \yluego$ \\
    $((\&n \neq e.raiz) \impluego (\paratodo{nodo}{n'})(n.padre = \&n' \Leftrightarrow n'.izq = \&n \lor n'.der = \&n)$)))
  }

  ~

  \Abs[estrAVL]{dicc($\kappa$, $\sigma$))}[e]{$d$}{
    ($\paratodo{k}{\kappa}$) ((def?($k$, $d$)) $\igobs$ ($k$ $\in$ claves($e$)) $\yluego$
    (def?($k$, $d$) $\impluego$ obtener($k$, $d$) $\igobs$ significado($k$, $e$)))
  }

  ~

  \tadOperacion{hijos}{nodo}{conj(nodo)}{}
  \tadAxioma{hijos($n$)}{\IF $n.izq$ = NULL THEN $\emptyset$ ELSE Ag($*$($n.izq$), hijos($*$($n.izq$))) FI \\
  $\cup$ \IF $n.der$ = NULL THEN $\emptyset$ ELSE Ag($*$($n.der$), hijos($*$($n.der$))) FI}

  ~

  \tadOperacion{nodos}{estrAVL}{conj(nodo)}{}
  \tadAxioma{nodos($e$)}{\IF $e.raiz$ = NULL THEN $\emptyset$ ELSE Ag($*$($e.raiz$), hijos($*$($e.raiz$))) FI}

  ~

  % \tadOperacion{sub\'arbol}{nodo}{estrAVL}{}
  % \tadAxioma{sub\'arbol($n$)}{$\langle \&n$, $1 + \#$(hijos($n$))$\rangle$}

  % ~

  \tadOperacion{sub\'arbol}{puntero(nodo)}{estrAVL}{}
  \tadAxioma{sub\'arbol($p$)}{$\langle p$, $1 + \#$(hijos($*$($p$)))$\rangle$}

  ~

  \tadOperacion{claves}{estrAVL}{conj($\kappa$)}{}
  \tadAxioma{claves($e$)}{\IF $e.raiz = \NULL$ THEN $\emptyset$ ELSE Ag($e.raiz \to clave$, claves(sub\'arbol($e.raiz \to izq$)) $\cup$ claves(sub\'arbol($e.raiz \to der$))) FI}

  ~

  \tadOperacion{altura}{estrAVL}{nat}{}
  \tadAxioma{altura($e$)}{\IF $e.raiz = \NULL$ THEN 0 ELSE 1 + m\'ax(altura(sub\'arbol($e.raiz \to izq$)), altura(sub\'arbol($e.raiz \to der$))) FI}

  ~

  \tadOperacion{significado}{estrAVL/e,$\kappa$/k}{$\sigma$}{$k$ $\in$ claves($e$)}
  \tadAxioma{significado($e$, $k$)}{\IF $e.raiz \to clave = k$ THEN $e.raiz \to significado$ ELSE {\IF $k$ $\in$ claves(sub\'arbol($e.raiz \to izq$)) THEN significado($k$, sub\'arbol($e.raiz \to izq$)) ELSE significado($k$, sub\'arbol($e.raiz \to der$)) FI} FI}

\end{Representacion}

\begin{Algoritmos}

  \SetKwFunction{fdb}{FDB}
  \SetKwFunction{raizq}{RotarAIzquierda}
  \SetKwFunction{rader}{RotarADerecha}
  \SetKwFunction{buscar}{Buscar}
  \SetKwFunction{max}{max}
  \SetKwFunction{rebalancear}{RebalancearArbol}
  \SetKwFunction{recalcAlt}{RecalcularAltura}
  % \SetKwFunction{recalcAlts}{RecalcularAlturas}

  \begin{algoritmo}{iVacio}{}{estrAVL}
    $res \gets \langle$NULL, 0$\rangle$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iDefinir}{\Inout{e}{estrAVL}, \In{k}{$\kappa$}, \In{s}{$\sigma$}}{}
    \tipo{puntero(nodo)} $padre \gets \NULL$ \com*{$\Theta(1)$}
    \tipo{puntero(nodo)} $lugar \gets$ \buscar{$e$, $k$, $padre$} \com*{$\Theta(\log(n) \times order(k))$}
    \eIf(\com*[f]{$\Theta(1)$}){$lugar \neq \NULL$}{
      $(lugar \to significado) \gets$ \copiar{$s$} \com*{$\Theta(copy(s))$}
    }{
      \tipo{puntero(nodo)} $nuevo \gets \new \langle$\copiar{$k$}, \copiar{$s$}, NULL, NULL, NULL, $1 \rangle$ \tcp*[h]{Reservamos memoria para el nuevo nodo} \com*{$\Theta(copy(k) + copy(s))$}
      \eIf(\com*[f]{$\Theta(order(k))$}){$k \leq (padre \to clave)$}{
        $(padre \to izq) \gets nuevo$ \com*{$\Theta(1)$}
      }{
        $(padre \to der) \gets nuevo$ \com*{$\Theta(1)$}
      }
      $(nuevo \to padre) \gets padre$ \com*{$\Theta(1)$}
      % \recalcAlts($padre$) \;
      \rebalancear($padre$) \com*{$\Theta(\log(n))$}
      $e.cantNodos ++$ \com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n) \times order(k) + copy(k) + copy(s))$} % Complejidad
  {La funci\'on tiene llamadas a funciones con complejidad $\Theta(\log(n) \times order(k)$ y $\Theta(copy(k) + copy(s))$.} % Justificacíón

  \begin{algoritmo}{iObtener}{\In{e}{estrAVL}, \In{k}{$\kappa$}}{$\sigma$}
    \tipo{puntero(nodo)} $padre \gets \NULL$ \com*{$\Theta(1)$}
    \tipo{puntero(nodo)} $lugar \gets$ \buscar{$e$, $k$, $padre$} \com*{$\Theta(\log(n) \times order(k))$}
    $res \gets (lugar \to significado)$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n) \times order(k))$} % Complejidad
  {La funci\'on tiene llamadas a funciones con complejidad $\Theta(\log(n) \times order(k)$ y $\Theta(copy(k) + copy(s))$.} % Justificacíón

  \begin{algoritmo}{i\#Claves}{\In{e}{estrAVL}}{nat}
    $res \gets e.cantNodos$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iDefinido?}{\In{e}{estrAVL}, \In{k}{$\kappa$}}{bool}
    \tipo{puntero(nodo)} $padre \gets \NULL$ \com*{$\Theta(1)$}
    \tipo{puntero(nodo)} $lugar \gets$ \buscar{$e$, $k$, $padre$} \com*{$\Theta(\log(n) \times order(k))$}
    $res \gets (lugar \neq \NULL)$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n) \times order(k))$} % Complejidad
  {$\Theta(1) + \Theta(\log(n) \times order(k)) + \Theta(1) = \Theta(\log(n) \times order(k)) + \Theta(1)$} % Justificación

  \begin{algoritmo}{iBorrar}{\Inout{e}{estrAVL}, \In{k}{$\kappa$}}{}
    \tipo{puntero(nodo)} $padre \gets \NULL$ \com*{$\Theta(1)$}
    \tipo{puntero(nodo)} $lugar \gets$ \buscar{$e$, $k$, $padre$} \com*{$\Theta(\log(n) \times order(k))$}
    \uIf(\com*[f]{$\Theta(1)$}){$lugar \to izq = \NULL \land lugar \to der = \NULL$}{
      \eIf(\com*[f]{$\Theta(1)$}){$padre \neq \NULL$}{
        \eIf(\com*[f]{$\Theta(1)$}){$padre \to izq = lugar$}{
          $(padre \to izq) \gets \NULL$ \com*{$\Theta(1)$}
        }{
          $(padre \to der) \gets \NULL$ \com*{$\Theta(1)$}
        }
        % \recalcAlts{$padre$} \;
        \rebalancear{$padre$} \com*{$\Theta(\log(n))$}
      }{
        $e.raiz = \NULL$ \com*{$\Theta(1)$}
      }
    }\uElseIf(\com*[f]{$\Theta(1)$}){$lugar \to der = \NULL$}{
      $(lugar \to izq \to padre) \gets padre$ \com*{$\Theta(1)$}
      \eIf(\com*[f]{$\Theta(1)$}){$padre \neq \NULL$}{
        \eIf(\com*[f]{$\Theta(1)$}){$padre \to izq = lugar$}{
          $(padre \to izq) \gets (lugar \to izq)$ \com*{$\Theta(1)$}
        }{
          $(padre \to der) \gets (lugar \to izq)$ \com*{$\Theta(1)$}
        }
        % \recalcAlts{$padre$} \;
        \rebalancear{$padre$} \com*{$\Theta(\log(n))$}
      }{
        $e.raiz \gets lugar \to izq$ \com*{$\Theta(1)$}
      }
    }\uElseIf(\com*[f]{$\Theta(1)$}){$lugar \to izq = \NULL$}{
      $(lugar \to der \to padre) \gets padre$ \com*{$\Theta(1)$}
      \eIf(\com*[f]{$\Theta(1)$}){$padre \neq \NULL$}{
        \eIf(\com*[f]{$\Theta(1)$}){$padre \to izq = lugar$}{
          $(padre \to izq) \gets (lugar \to der)$ \com*{$\Theta(1)$}
        }{
          $(padre \to der) \gets (lugar \to der)$ \com*{$\Theta(1)$}
        }
        % \recalcAlts{$padre$} \;
        \rebalancear{$padre$} \com*{$\Theta(\log(n))$}
      }{
        $e.raiz \gets lugar \to izq$ \com*{$\Theta(1)$}
      }
    }
  \end{algoritmo}

  \begin{contAlgoritmo}{iBorrar}
    \Else{
      \tipo{puntero(nodo)} $reemplazo \gets (lugar \to der)$ \com*{$\Theta(1)$}
      \eIf(\com*[f]{$\Theta(1)$}){$(reemplazo \to izq = \NULL)$}{
        \eIf(\com*[f]{$\Theta(1)$}){$padre \neq \NULL$}{
          \eIf(\com*[f]{$\Theta(1)$}){$(padre \to izq) = lugar$}{
            $(padre \to izq) \gets reemplazo$ \com*{$\Theta(1)$}
          }{
            $(padre \to der) \gets reemplazo$ \com*{$\Theta(1)$}
          }
        }{
          $e.raiz \gets reemplazo$ \com*{$\Theta(1)$}
        }
        $(reemplazo \to padre) \gets padre$ \com*{$\Theta(1)$}
        $(reemplazo \to izq) \gets lugar \to izq$ \com*{$\Theta(1)$}
        $(lugar \to izq \to padre) \gets reemplazo$ \com*{$\Theta(1)$}
        % \recalcAlts{$reemplazo$} \;
        \rebalancear{$reemplazo$} \com*{$\Theta(\log(n))$}
      }{
        \While(\com*[f]{$\Theta(\log(n))$ iteraciones}){$(reemplazo \to izq) \neq \NULL$}{
          $reemplazo \gets (reemplazo \to izq)$ \com*{$\Theta(1)$}
        }
        \tipo{puntero(nodo)} $padreReemplazo \gets (reemplazo \to padre)$ \com*{$\Theta(1)$}
        \eIf(\com*[f]{$\Theta(1)$}){$padre \neq \NULL$}{
          \eIf(\com*[f]{$\Theta(1)$}){$padre \to izq = lugar$}{
            $(padre \to izq) \gets reemplazo$ \com*{$\Theta(1)$}
          }{
            $(padre \to der) \gets reemplazo$ \com*{$\Theta(1)$}
          }
        }{
          $e.raiz \gets reemplazo$ \com*{$\Theta(1)$}
        }
        $(reemplazo \to padre) \gets padre$ \com*{$\Theta(1)$}
        $(reemplazo \to izq) \gets lugar \to izq$ \com*{$\Theta(1)$}
        $(lugar \to izq \to padre) \gets reemplazo$ \com*{$\Theta(1)$}
        $(padreReemplazo \to izq) \gets (reemplazo \to der)$ \com*{$\Theta(1)$}
        \If(\com*[f]{$\Theta(1)$}){$(reemplazo \to der) \neq \NULL$}{
          $(reemplazo \to der \to padre) \gets padreReemplazo$ \com*{$\Theta(1)$}
        }
        $(reemplazo \to der) \gets (lugar \to der)$ \com*{$\Theta(1)$}
        $(lugar \to der \to padre) \gets reemplazo$ \com*{$\Theta(1)$}
        % \recalcAlts{$reemplazo$} \;
        \rebalancear{$reemplazo$} \com*{$\Theta(\log(n))$}
      }
    }
    \delete{$lugar$} \tcp*[h]{Liberamos la memoria ocupada por el nodo eliminado.} \com*{$\Theta(1)$}
  \end{contAlgoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n) \times order(k))$} % Complejidad
  {El algoritmo tiene una llamada a funci\'on con complejidad $\Theta(\log(n) \times order(k))$, y luego presenta varios casos, pero en todos ellos las funciones llamadas son $O(\log(n))$.} % Justificación

  \begin{algoritmo}{iBuscar}{\In{e}{estrAVL}, \In{k}{$\kappa$}, \Out{padre}{puntero(nodo)}}{puntero(nodo)}
    $padre \gets \NULL$  \com*{$\Theta(1)$}
    $actual \gets e.raiz$  \com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(\log(n))$ iteraciones}){$actual \neq \NULL \yluego (actual \to clave \neq k)$}{ % ¡Preguntar por el y luego!
      $padre \gets actual$ \com*{$\Theta(1)$}
      \eIf(\com*[f]{$\Theta(order(k))$}){$k \leq (padre \to clave)$}{
        $actual \gets (actual \to izq)$ \com*{$\Theta(1)$}
      }{
        $actual \gets (actual \to der)$ \com*{$\Theta(1)$}
      }
    }
    $res \gets actual$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe la estructura de representaci\'on interna del diccionario y una clave por par\'ametro. Si la clave est\'a definida, devuelve un puntero al nodo que la contiene y coloca en el par\'ametro de out $padre$ un puntero al padre de dicho nodo. En caso contrario, devuelve NULL y coloca en el par\'ametro de out $padre$ un puntero a la hoja del \'arbol que deber\'ia ser padre del nodo buscado, si la clave estuviera definida.} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n) \times order(k))$} % Complejidad
  {El algoritmo presenta un ciclo que se repite $\Theta(\log(n))$ veces, y en cada una de ellas se realiza una llamada a funci\'on con complejidad $\Theta(order(k))$.} % Justificación

  % \begin{algoritmo}{iRecalcularAlturas}{\In{n}{puntero(nodo)}}{}
  %   \tipo{puntero(nodo)} $p \gets n$ \com*{$\Theta(1)$}
  %   \While(\com*[f]{$\Theta(\log(n))$ iteraciones}){$p \neq \NULL$}{
  %     \uIf{$p \to izq \neq \NULL \land p \to der \neq \NULL$}{
  %       $(p \to altSubarbol) \gets 1$ + \max{$p \to izq \to altSubarbol$, $p \to der \to altSubarbol$} \com*{$\Theta(1)$}
  %     }\uElseIf{$p \to izq \neq \NULL$}{
  %       $(p \to altSubarbol) \gets 1 + (p \to izq \to altSubarbol)$ \com*{$\Theta(1)$}
  %     }\uElseIf{$p \to der \neq \NULL$}{
  %       $(p \to altSubarbol) \gets 1 + (p \to der \to altSubarbol)$ \com*{$\Theta(1)$}
  %     }\Else{
  %       $(p \to altSubarbol) \gets 1$ \com*{$\Theta(1)$}
  %     }
  %     $p \gets (p \to padre)$ \com*{$\Theta(1)$}
  %   }
  % \end{algoritmo}
  % \datosAlgoritmo{} % Descripción
  % {} % Pre
  % {} % Post
  % {$\Theta(\log(n))$} % Complejidad
  % {} % Justificación

  \begin{algoritmo}{iRecalcularAltura}{\In{n}{puntero(nodo)}}{}
    \uIf(\com*[f]{$\Theta(1)$}){$n \to izq \neq \NULL \land n \to der \neq \NULL$}{
      $(n \to altSubarbol) \gets 1$ + \max{$n \to izq \to altSubarbol$, $n \to der \to altSubarbol$} \com*{$\Theta(1)$}
    }\uElseIf(\com*[f]{$\Theta(1)$}){$n \to izq \neq \NULL$}{
      $(n \to altSubarbol) \gets 1 + (n \to izq \to altSubarbol)$ \com*{$\Theta(1)$}
    }\uElseIf(\com*[f]{$\Theta(1)$}){$n \to der \neq \NULL$}{
      $(n \to altSubarbol) \gets 1 + (n \to der \to altSubarbol)$ \com*{$\Theta(1)$}
    }\Else{
      $(n \to altSubarbol) \gets 1$ \com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe un puntero a un nodo del \'arbol y recalcula el valor de su campo $altSubarbol$ en funci\'on a los datos que sus nodos hijos poseen en este campo.} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {El algoritmo presenta varios casos, y todos ellos realizan realizan operaciones con complejidad $\Theta(1)$.} % Justificación

  \begin{algoritmo}{iFBD}{\In{n}{puntero(nodo)}}{int}
    \tipo{int} $altIzq \gets n \to izq = \NULL$ ? 0 : $n \to izq \to altSubarbol$ \com*{$\Theta(1)$}
    \tipo{int} $altDer \gets n \to der = \NULL$ ? 0 : $n \to izq \to altSubarbol$ \com*{$\Theta(1)$}
    $res \gets altDer - altIzq$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe un puntero a un nodo del \'arbol y calcula su factor de balanceo.} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {$\Theta(1) + \Theta(1) + \Theta(1) = \Theta(1)$} % Justificación

  \begin{algoritmo}{iRotarAIzquierda}{\In{n}{puntero(nodo)}}{}
    \If(\com*[f]{$\Theta(1)$}){$n.padre \neq \NULL$}{
      \eIf(\com*[f]{$\Theta(1)$}){$n.padre \to izq = n$}{
        $(n \to padre \to izq) \gets n \to der$ \com*{$\Theta(1)$}
      }{
        $(n \to padre \to der) \gets n \to der$ \com*{$\Theta(1)$}
      }
    }
    $(n \to der \to padre) \gets n \to padre$ \com*{$\Theta(1)$} 
    $n \to padre \gets n \to der$ \com*{$\Theta(1)$}
    $n \to der \gets (n \to der \to izq)$ \com*{$\Theta(1)$}
    \If(\com*[f]{$\Theta(1)$}){$n \to der \neq \NULL$}{
      $(n \to der \to padre) \gets n$ \com*{$\Theta(1)$}
    }
    $(n \to padre \to izq) \gets n$ \com*{$\Theta(1)$}
    \recalcAlt{$n$} \com*{$\Theta(1)$}
    \recalcAlt{$n \to padre$} \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe un puntero a un nodo del \'arbol y realiza una rotaci\'on a izquierda de dicho nodo. !`Ojo, rompe el invariante de representaci\'on! (Los campos $altSubarbol$ de los nodos superiores quedan inconsistentes).} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {Todas las operaciones que realiza el algoritmo tienen complejidad $\Theta(1)$.} % Justificación

  \begin{algoritmo}{iRotarADerecha}{\In{n}{puntero(nodo)}}{}
    \If(\com*[f]{$\Theta(1)$}){$n \to padre \neq \NULL$}{
      \eIf(\com*[f]{$\Theta(1)$}){$n \to padre \to izq = n$}{
        $(n \to padre \to izq) \gets n \to izq$ \com*{$\Theta(1)$}
      }{
        $(n \to padre \to der) \gets n \to izq$ \com*{$\Theta(1)$}
      }
    }
    $(n \to izq \to padre) \gets n \to padre$ \com*{$\Theta(1)$} 
    $n \to padre \gets n \to izq$ \com*{$\Theta(1)$}
    $n \to izq \gets (n \to izq \to der)$ \com*{$\Theta(1)$}
    \If(\com*[f]{$\Theta(1)$}){$n \to izq \neq \NULL$}{
      $(n \to izq \to padre) \gets n$ \com*{$\Theta(1)$}
    }
    $(n \to padre \to der) \gets n$ \com*{$\Theta(1)$}
    \recalcAlt{$n$} \com*{$\Theta(1)$}
    \recalcAlt{$n \to padre$} \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe un puntero a un nodo del \'arbol y realiza una rotaci\'on a derecha de dicho nodo. !`Ojo, rompe el invariante de representaci\'on! (Los campos $altSubarbol$ de los nodos superiores quedan inconsistentes).} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {Todas las operaciones que realiza el algoritmo tienen complejidad $\Theta(1)$.} % Justificación

  \begin{algoritmo}{iRebalancearArbol}{\In{n}{puntero(nodo)}}{}
    \tipo{puntero(nodo)} $p \gets n$ \com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(\log(n))$ iteraciones}){$p \neq \NULL$}{ 
      \recalcAlt{$p$} \com*{$\Theta(1)$}
      \tipo{int} $fdb1 \gets$ \fdb{$p$} \com*{$\Theta(1)$}
      \uIf(\com*[f]{$\Theta(1)$}){$fdb1 = 2$}{
        \tipo{puntero(nodo)} $q \gets (p \to der)$ \com*{$\Theta(1)$}
        \tipo{int} $fdb2 \gets$ \fdb{$q$} \com*{$\Theta(1)$}
        \uIf(\com*[f]{$\Theta(1)$}){$fdb2 = 1 \lor fdb2 = 0$}{
          \raizq{$p$} \com*{$\Theta(1)$}
          $p \gets q$ \com*{$\Theta(1)$}
        }\ElseIf(\com*[f]{$\Theta(1)$}){$fbd2 = -1$}{
          \rader{$q$} \com*{$\Theta(1)$}
          \raizq{$p$} \com*{$\Theta(1)$}
          $p \gets (q \to padre)$ \com*{$\Theta(1)$}
        }
      }\ElseIf{$fdb1 = -2$}{
        \tipo{puntero(nodo)} $q \gets (p \to izq)$ \com*{$\Theta(1)$}
        \tipo{int} $fdb2 \gets$ \fdb{$q$} \com*{$\Theta(1)$}
        \uIf(\com*[f]{$\Theta(1)$}){$fdb2 = -1 \lor fdb2 = 0$}{
          \rader{$p$} \com*{$\Theta(1)$}
          $p \gets q$ \com*{$\Theta(1)$}
        }\ElseIf(\com*[f]{$\Theta(1)$}){$fbd2 = 1$}{
          \raizq{$q$} \com*{$\Theta(1)$}
          \rader{$p$} \com*{$\Theta(1)$}
          $p \gets (q \to padre)$ \com*{$\Theta(1)$}
        }
      }
      $p \gets (p \to padre)$ \com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{Esta operaci\'on privada recibe un puntero a un nodo del \'arbol y restaura el invariante de representaci\'on en la rama ascendente a partir de dicho nodo, realizando las rotaciones necesarias para rebalancear el \'arbol.} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(\log(n))$} % Complejidad
  {El algoritmo presenta un ciclo que se ejecuta $\Theta(\log(n))$ veces, y en cada una de ellas se realizan operaciones con complejidad $\Theta(1)$.} % Justificación

\end{Algoritmos}
