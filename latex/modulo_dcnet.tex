\section{M\'odulo DCNet}

\begin{Interfaz}
  
  \textbf{se explica con:} \tadNombre{DCNet}
  
  \textbf{g\'eneros:} \TipoVariable{dcnet}
  
  \Titulo{Operaciones b\'asicas de lista}

  \InterfazFuncion{iniciarDCNet}{\In{r}{Red}}{DCNet}%
  [true]%pre
  {res $\igobs$ iniciarDCNet(r)}%pos
  [$\Theta(1234)$]%complejidad
  [Genera un nuevo DCNet sin paquetes. "vac\'ia" ]%descripcion
  []%aliasing
  
  \InterfazFuncion{crearPaquete}{\Inout{D}{DCNet}, \In{p}{paquete}}{}%
  [D $\igobs$ $D_{0}$ $\land$ $\not$(($\exists p'$: paquete)(paqueteEnTransito?(D,p') $\land$ id(p') = id(p)) $\land$ origen(p) $\in$ computadoras(red(D)) $\yluego$ destino(p) $\in$ computadoras(red(D)) $\yluego$ hayCamino?(red(D), origen(p), destino(p)))]%pre
  {D $\igobs$ crearPaquete($D_{0}$, p)}%pos
  [$\Theta(l+log(k))$]%complejidad
  [Crea un nuevo paquete que no exite en el DCNet anterior. ]%descripcion
  []%aliasing

  \InterfazFuncion{avanzarSegundo}{\Inout{D}{DCNet}}{}%
  [D $\igobs$ $D_{0}$]%pre
  {D $\igobs$ avanzarSegundo($D_{0}$)}%pos
  [$\Theta(n.(L+log(n)+log(k)))$]%complejidad
  [Avanza un segundo en el DCNet, moviendo todos los paquetes correspondientes. ]%descripcion
  []%aliasing

  \InterfazFuncion{red}{\In{D}{DCNet}}{red}%
  [true]%pre
  {res $\igobs$ red(D)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve la red donde esta funcionando el DCNet. ]%descripcion
  []%aliasing

  \InterfazFuncion{caminoRecorido}{\In{D}{DCNet}, \In{p}{paquete}}{secu(compu)}%
  [paqueteEnTrancito?(D, p)]%pre
  {res $\gobs$ caminoRecorrido(D, p)}%pos
  [$\Theta(n.log(max(n,k)))$]%complejidad
  [Devuelve la secuencia que contiene de forma ordenada todas las computadoras por las que fue pasando. ]%descripcion
  []%aliasing

  \InterfazFuncion{cantidadEnviados}{\In{D}{DCNet}, \In{c}{compu}}{nat}%
  [c $\in$ computadoras(red(D))]%pre
  {res $\igobs$ cantidadEnviados(D, c)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve la cantidad de paquetes que envi\'o la computadora 'c'. ]%descripcion
  []%aliasing

  \InterfazFuncion{enEspera}{\In{D}{DCNet}, \In{c}{compu}}{conj(paquete)}%
  [c $\in$ computadoras(red(D))]%pre
  {res $\igobs$ enEspera(D, c)}%pos
  [$\Theta(L)$]%complejidad
  [Devuelve los paquetes que tiene en espera la compu 'c'. ]%descripcion
  []%aliasing

  \InterfazFuncion{paquetesEnEspera?}{\In{D}{DCNet}, \In{p}{paquete}}{bool}%
  [true]%pre
  {res $\igobs$ paquetesEnTrancito?(D, p)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve 'True' si y solo si el paquete esta en los paquetes en espera de alguna computadora. ]%descripcion
  []%aliasing

  \InterfazFuncion{laQueMasEnvio}{\In{D}{DCNet}}{compu}%
  [true]%pre
  {res $\igobs$ laQueMasEnvio(D)}%pos
  [$\Theta(1)$]%complejidad
  [Devuelve una de las computadoras con mas paquetes enviados]%descripcion
  []%aliasing

  \InterfazFuncion{NOMBRE}{PARAMTROS}{RES}%
  []%pre
  {}%pos
  []%complejidad
  []%descripcion
  []%aliasing

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{dcnet}[estrDCNet]

    \begin{Tupla}[estrDCNet]
      \tupItem{estrRed}{red}
      \tupItem{IDsCompusPorIP}{dicc\_trie(string, nat)}
      \tupItem{siguientesCompus}{arregloDimensionable(arregloDimensionable(nat))}
      \tupItem{paqEnEspera}{arregloDimensionable(tupla(conjunto(paquete), colaPrior(tupla(nat, itConjunto(paquete))), dicc\_AVL(itConjunto(paquete))))}
      \tupItem{\#PaqEnviados}{arregloDimensionable(nat)}
      \tupItem{laQueM\'asEnvi\'o}{itRed}
      \tupItem{\'ultimoId}{nat}
    \end{Tupla}

  \end{Estructura} 

	\Rep[e][l]{
	($\forall e$: estr)(
%1
		(tam(e.paquetesEnEspera) = tam(e.IPcompusXID) = tam(e.siguienteCompu) = tam (e.cantPaquetesEnviados) = #(computaodras(e.estrRed))) $\land$ 
		($\forall n$: nat)(definido?(e.siguienteCompu,n) $\impluego$ tam(e.siguienteCompu[n]) = #(computadoras(e.estrRed))) $\land$
%2
		Maximo(e.cantPaqEnviados) = e.cantidadEnviados[obtener($\pi_1$(siguiente(e.laQueMasEnvio)),e.IDcompusPorIP)] $\land$
%3 CHEQUEAR PARENTESIS
		($\forall c$: compu)(c $\in$ computadoras(e.estRed) $\impluego$ obtener($\pi_1$(c),e.IDcompusPorIP) < #(computadoras(e.estrRed))) $\land$
		(($\forall c_1$, $c_2$: compu)(($c_1 \in$ computadoras(e.estRed) $\land$ ($c_2 \in$ computadoras(e.estrRed)) $\land$ ($c_1 \neq c_2$)) $\impluego$ ((obtener($\pi_1$($c_1$), e.IDcompusPorIP) $\neq$ obtener($\pi_1$($c_2$), e.IDcompusPorIP))))) $\land$
%4
		(dameNombres(computadoras(e.estrRed)) = claus(IDcompusPorIP)) $\land$
%5
		($\forall L$: nat)( 0 $\leq$ L < tam(e.paqEnEspera) $\impluego$ (
			($\forall i$: ItConj(paquete))(siguiente(i) $\in$ (dameSiguientes(dame$\pi_1$($juntarSignificados_1$($\pi_2$(e.paquetesEnEspera[L])))$\impluego$ siguiente(i) $\in \pi_1$(e.paquetesEnEspera[L])))) $\land$ 
			($\forall c$: ID)(c$\in$ claves($\pi_2$(e.paquetesEnEspera[L])) $\impluego \pi_1$(siguiente($\pi_1$(obtener($\pi_2$(c), e.paquetesEnEspera[L])))) = c) $\land$
			($\forall i$: ItConj(paquete))(siguiente(i)$\in$ dameSiguientes(dame$\pi_1$($juntarSignificados_2$($\pi_3$(e.paquetesEnEspera[L])))) $\impluego$ siguiente(i) $\in \pi_1$(e.paquetesEnEspera[L]))$\land$
			($\forall n$: prioridad)(definido?($\pi_3$(e.paquetesEnEspera[L]),n) $\impluego$ ($\forall p$: paquete)(esta?(p, obtener(n, $\pi_3$(e.paquetesEnEspera[L]))) $\impluego$ $\pi_2$(p) = n)) $\land$
% *1
    ($\forall x$, $z$: nat)((0 $\leq$ x < tam(e.paquetesEnEspera) $\land$ 0 $\leq$ z < tam(e.paquetesEnEspera) $\land$ x $\neq$ z) $\impluego$ ($\pi_1$(e.paquetesEnEspera[x]) $\cap$ $\pi_2$(e.paquetesEnEspera[z])) = $\emptyset$) $\land$
%6
		($\forall i$: nat)(0 $\leq$ i < #(computadoras(e.estrRed)) $\land$ obtener($\pi_1$(siguiente(e.IPcompusPorID[i])), e.IDcompusPorID) = i) $\land$
%7
		($\forall n$, $m$: nat)(0 $\leq$ n < #(computadoras(e.estrRed)) $\land$ 0 $\leq$ n < #(computadoras(e.estrRed)) $\impluego$ e.siguienteCompu[n][m] = prim(dameuno(caminosminimos(e.estrRed,siguiente(e.IPcompusporID[n]),siguiente(e.IPcompusPorID[m]))))) $\land$
%8
    ($\forall i$: nat)(0 $\leq$ i $\leq$ #computadoras(e.estrRed) $\impluego$ siguiente(e.IPcompusPorID[i]) $\in$ compitadoras(e.estrRed)) $\land$
% *2
    ($\forall x$, $y$: nat)((0 $\leq$ x < #computadoras(e.estrRed) $\land$ 0 $\leq$ y < #computadoras(e.estrRed) $\land$ x $\neq$ y) $\impluego$ (siguiente(e.IPcompusPorID[x]) $\neq$ siguiente(e.IPcompusPorID[y]))))) $\land$
%9
    #($\pi_1$(e.paquetesEnEspera)) = #claves($\pi_2$(e.paquetesEnEspera)) $\land$ = #(juntarSecuenciasEnConj(juntarSignificados($\pi_3$(e.paquetesEnEspera)))) $\land$
%10?
    ($\forall it_1$: ItConj(paquete))($\forall it_2$: ItConj(paquete))(($it_1 \in$ juntarSecuEnConj(JuntarSignificado($\pi_3$(e.paquetesEnEspera[L])))) $\land$ ($it_2 \in$ juntarSecuEnConj(JuntarSignificado($\pi_3$(e.paquetesEnEspera[L])))) $\land$ ($it_1$ $\neq$ $it_2$) $\impluego$ (siguiente($it_1)$ $\neq$ siguiente($it_2$)))
	)}\mbox{}

  ~      

  \tadOperacion{Nodo}{lst/l,nat}{puntero(nodo)}{$l$.primero $\neq$ NULL}
  \tadAxioma{Nodo($l$,$i$)}{\IF $i = 0$ THEN $l$.primero ELSE Nodo(FinLst($l$), $i-1$) FI}

  ~
\end{Representacion}
