\section{M\'{o}dulo DCNet}

\Encabezado{Notas preliminares}
  En todos los casos, al indicar las complejidades de los algoritmos, las variables que se utilizan corresponden a:
  \vspace{-0.5em}\begin{itemize}
    \item $n$: N\'umero de computadoras en la red.
    \item $k$: Longitud de la cola de paquetes m\'as larga al momento.
    \item $L$: Longitud de nombre de computadora m\'as largo de la red.
    \item $i$: Mayor cantidad de interfaces que tiene alguna computadora en la red en el momento.
  \end{itemize}

\begin{Interfaz}
  
  \seExplicaCon{DCNet}
  
  \generos{\tipo{dcnet}}
  
  \Encabezado{Operaciones b\'asicas de lista} % Â¿?

  \InterfazFuncion{iniciarDCNet}{\In{r}{Red}}{DCNet}%
  [true]%pre
  {res $\igobs$ iniciarDCNet(r)}%pos
  [$\Theta(n^3 \times I^2 \times L + camMin)$]%complejidad
  [Genera un nuevo DCNet sin paquetes. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{crearPaquete}{\Inout{D}{DCNet}, \In{p}{paquete}}{}%
  [D $\igobs$ $D_{0}$ $\land$ $\not$(($\exists p'$: paquete)(paqueteEnTransito?(D,p') $\land$ id(p') = id(p)) $\land$ origen(p) $\in$ computadoras(red(D)) $\yluego$ destino(p) $\in$ computadoras(red(D)) $\yluego$ hayCamino?(red(D), origen(p), destino(p)))]%pre
  {D $\igobs$ crearPaquete($D_{0}$, p)}%pos
  [$\Theta(L+log(k))$]%complejidad
  [Crea un nuevo paquete que no exite en el DCNet anterior. ]%descripcion
  []%aliasing

  \InterfazFuncion{avanzarSegundo}{\Inout{D}{DCNet}}{}%
  [D $\igobs$ $D_{0}$]%pre
  {D $\igobs$ avanzarSegundo($D_{0}$)}%pos
  [$\Theta(n \times log(k))$]%complejidad
  [Avanza un segundo en el DCNet, moviendo todos los paquetes correspondientes. ]%descripcion
  []%aliasing

  \InterfazFuncion{red}{\In{D}{DCNet}}{red}%
  [true]%pre
  {esAlias(res $\igobs$ red(D))}%pos
  [$\Theta(1)$]%complejidad
  [Devuelve la red donde esta funcionando el DCNet. ]%descripcion
  [Pasamos la red por referencia]%aliasing

  \InterfazFuncion{caminoRecorido}{\In{D}{DCNet}, \In{p}{paquete}}{secu(compu)}%
  [paqueteEnTransito?(D, p)]%pre
  {res $\igobs$ caminoRecorrido(D, p)}%pos
  [$\Theta(n \times log(k))$]%complejidad
  [Devuelve la secuencia que contiene de forma ordenada todas las computadoras por las que fue pasando. ]%descripcion
  []%aliasing

  \InterfazFuncion{cantidadEnviados}{\In{D}{DCNet}, \In{c}{compu}}{nat}%
  [c $\in$ computadoras(red(D))]%pre
  {res $\igobs$ cantidadEnviados(D, c)}%pos
  [$\Theta(L)$]%complejidad
  [Devuelve la cantidad de paquetes que envi\'o la computadora ``c''. ]%descripcion
  []%aliasing

  \InterfazFuncion{enEspera}{\In{D}{DCNet}, \In{c}{compu}}{conj(paquete)}%
  [c $\in$ computadoras(red(D))]%pre
  {res $\igobs$ enEspera(D, c)}%pos
  [$\Theta(L)$]%complejidad
  [Devuelve los paquetes que tiene en espera la compu ``c''. ]%descripcion
  []%aliasing

  \InterfazFuncion{paquetesEnTr\'ansito?}{\In{D}{DCNet}, \In{p}{paquete}}{bool}%
  [true]%pre
  {res $\igobs$ paquetesEnTrancito?(D, p)}%pos
  [$\Theta(n \times log(k))$]%complejidad
  [Devuelve ``True'' si y solo si el paquete esta en los paquetes en espera de alguna computadora. ]%descripcion
  []%aliasing

  \InterfazFuncion{laQueM\'asEnvi\'o}{\In{D}{DCNet}}{compu}%
  [true]%pre
  {res $\igobs$ laQueM\'asEnvi\'o(D)}%pos
  [$\Theta(1)$]%complejidad
  [Devuelve una de las computadoras con mas paquetes enviados]%descripcion
  []%aliasing

%  \InterfazFuncion{NOMBRE}{PARAMTROS}{RES}%
%  []%pre
%  {}%pos
%  []%complejidad
%  []%descripcion
%  []%aliasing

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{dcnet}[estrDCNet]

    \begin{Tupla}[estrDCNet]
      \tupItem{red}{red}
      \tupItem{IDsCompusPorIP}{dicc\_trie(string, nat)}
      \tupItem{siguientesCompus}{ad(ad(nat))}
      \tupItem{paquetesEnEspera}{ad(tupla(enConjunto: conj(paquete), porID: dicc\_AVL(ID, tupla(iPaquete: itConj(paquete),codOrigen: nat, codDestino: nat), porPrioridad: heap(tupla(prioridad, itConjunto(paquete))))))}
      \tupItem{\#PaqEnviados}{ad(nat)}
      \tupItem{laQueM\'asEnvi\'o}{itRed}
      \tupItem{IPsCompuPorID}{ad(itRed)}
    \end{Tupla}

  \end{Estructura} 

	\Rep[e][l]{
	($\forall e$: estr)(

%1
		(tam(e.paquetesEnEspera) = tam(e.IPcompusXID) = tam(e.siguienteCompu) = tam (e.cantPaquetesEnviados) = \#(computaodras(e.estrRed))) $\land$ 
		($\forall n$: nat)(definido?(e.siguienteCompu,n) $\impluego$ tam(e.siguienteCompu[n]) = \#(computadoras(e.estrRed))) $\land$

%2
		Maximo(e.cantPaqEnviados) = e.cantidadEnviados[obtener($\Pi_1$(siguiente(e.laQueM\'asEnvi\'o)),e.IDcompusPorIP)] $\land$
%3 CHEQUEAR PARENTESIS
		($\forall c$: compu)(c $\in$ computadoras(e.estRed) $\impluego$ obtener($\Pi_1$(c),e.IDcompusPorIP) < \#(computadoras(e.estrRed))) $\land$
		(($\forall c_1$, $c_2$: compu)(($c_1 \in$ computadoras(e.estRed) $\land$ ($c_2 \in$ computadoras(e.estrRed)) $\land$ ($c_1 \neq c_2$)) $\impluego$ ((obtener($\Pi_1$($c_1$), e.IDcompusPorIP) $\neq$ obtener($\Pi_1$($c_2$), e.IDcompusPorIP))))) $\land$

%4
		(dameNombres(computadoras(e.estrRed)) = claus(IDcompusPorIP)) $\land$

%5
		($\forall L$: nat)( 0 $\leq$ L < tam(e.paqEnEspera) $\impluego$ (

      ($\forall$ $it_1$: ItConj(paquete)) $it$ $\in$ dame$\Pi_1$(juntarSignificado($\Pi_2$(e.paquetesEnEspera[L]))) $\impluego$ haySiguiente?($it_1$) $\land$ \\

      ($\forall$ $it_2$: ITconj(pauqete)) $it_2$ $\in$ dame$Pi_2$(juntarColaEnConjunto($\Pi_3$(e.paquetesEnEspera[L]))) $\impluego$ haySiguiente?($it_2$) $\yluego$ \\

			($\forall i$: ItConj(paquete))(siguiente(i) $\in$ (dameSiguientes(dame$\Pi_1$($juntarSignificados_1$($\Pi_2$(e.paquetesEnEspera[L])))$\impluego$ siguiente(i) $\in \Pi_1$(e.paquetesEnEspera[L])))) $\land$ \\

			($\forall c$: ID)(c$\in$ claves($\Pi_2$(e.paquetesEnEspera[L])) $\impluego \Pi_1$(siguiente($\Pi_1$(obtener($\Pi_2$(c), e.paquetesEnEspera[L])))) = c) $\land$ \\

      ($\forall$ $it$:ItConj(paquete)) siguiente($it$) $\in$ dameSiguientes(dame$\Pi_2$(juntarColaPrioriEnConj($\Pi_3$(e.paquetesEnEspera[L])))) $\impluego$ siguiente($it$) $\in$ $\Pi_1$(e.paquetesEnEspera[L]) \\

			($\forall$ $t$: tupla <prioridad,ItConj(paquete)>) $t$ $\in$ juntarColaPrioriEnConj($\Pi_3$(e.paquetesEnEspera[L])) $\rightarrow$ siguiente($\Pi_2$($t$)).prioridad = $\Pi_1$($t$) \\

      % *1
    ($\forall x$, $z$: nat)((0 $\leq$ x < tam(e.paquetesEnEspera) $\land$ 0 $\leq$ z < tam(e.paquetesEnEspera) $\land$ x $\neq$ z) $\impluego$ ($\Pi_1$(e.paquetesEnEspera[x]) $\cap$ $\Pi_2$(e.paquetesEnEspera[z])) = $\emptyset$) $\land$ \\

%6
		($\forall i$: nat)(0 $\leq$ i < \#(computadoras(e.estrRed)) $\land$ obtener($\Pi_1$(siguiente(e.IPcompusPorID[i])), e.IDcompusPorID) = i) $\land$ \\

%7
		($\forall n$, $m$: nat)(0 $\leq$ n < \#(computadoras(e.estrRed)) $\land$ 0 $\leq$ n < \#(computadoras(e.estrRed)) $\impluego$ ($\exists$ $x$: (secu(compu))) $x$ $\in$ caminosminimos(e.estrRed, siguiente(e.IPcompusPorID[n]), siguiente(e.IPcompusPorID[m])) $\land$ prim($x$) $=$ e.siguienteCompu[n][m] \\

%8
    ($\forall i$: nat)(0 $\leq$ i $\leq$ \#computadoras(e.estrRed) $\impluego$ siguiente(e.IPcompusPorID[i]) $\in$ compitadoras(e.estrRed)) $\land$ \\

% *2
    ($\forall x$, $y$: nat)((0 $\leq$ x < \#computadoras(e.estrRed) $\land$ 0 $\leq$ y < \#computadoras(e.estrRed) $\land$ x $\neq$ y) $\impluego$ (siguiente(e.IPcompusPorID[x]) $\neq$ siguiente(e.IPcompusPorID[y]))))) $\land$ \\

%9
    \#($\Pi_1$(e.paquetesEnEspera)) = \#claves($\Pi_2$(e.paquetesEnEspera)) $\land$ = \#(juntarSecuenciasEnConj(juntarSignificados($\Pi_3$(e.paquetesEnEspera)))) $\land$ \\

%10
    ($\forall$ $it_{1}$: ItConj(paquete)) ($\forall$ $it_{2}$: ItConj(paquete)) $it_{1}$ $\in$ dame$\Pi_{2}$(juntarColaPriorEnConj($\Pi_{3}$(e.paquetesEnEspera[L]))) $\land$ $it_{2}$ $\in$ dame$\Pi_{2}$(juntarColaPriorEnConj($\Pi_{3}$(e.paquetesEnEspera[L]))) $it_{1}$ $\neq$ $it_{2}$ $\impluego$ siguiente($it_{1}$) $\neq$ siguiente($it_{2}$)
    }\mbox{} %habia un parentesis no se de donde sale (estaba cerrando en esta linea)


\AbsFc[estrDCNet]{DCNet}[e]{red($d$) = e.estrRed $\land$ \\

  ($\forall p$: paquete) paqueteEnTr\'ansito?($d$, $p$) $\impluego$ caminoRecorrido($d$, $p$) = caminoDelPaquete(e.siguienteCompu, e.IPsCompusPorID, e.PaquetesEnEspera, $p$) $\land$ \\

  ($\forall c$: compu) $c$ $\in$ computadoras(red($d$)) $\impluego$ cantidadEnviados($d$, $c$) = e.\#PaqEnviados[obtener($c$, e.IDsCompusPorIP)] $\land$ \\

  ($\forall c$: compu) $c$ $\in$ computadoras(red($d$)) $\impluego$ enEspera($d$, $c$) = enConjunto(e.paquetesEnEspera[obtener($c$, e.IDsCompusPorIP)])
}

  ~      

\tadOperacion{caminoDelPaquete}{ad(ad(nat)), ad(ItRed), ad(tupla(enConjunto: conj(paquete), porID: dicc$_{\text{AVL}}$(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))), paquete, ad(tupla(enConjunto: conj(paquete), porID: dicc\_AVL(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete))))))}{secu(compu)}{} %FALTA AGREGAR RESTRICCION y alinear bien los parametros - Manu  

\tadAxioma{caminoDelPaquete($t$, $CsxID$, $ps$, $p$, $Psr$)}{\IF def?(ID($p$), porID($ps$[0])) THEN caminoDelPaquete$_{\text{aux}}$($t$, $CsxID$, $ps$, $p$, codOrigen(obtener(ID($p$), porId($ps$[0]))), codDestino(obtener(ID($p$), porId($ps$[0])))) ELSE caminoDelPaquete($t$, $CsxID$, $ps$, $p$, finAd(psr)) FI}

  ~

\tadOperacion{caminoDelPaquete$_{\text{aux}}$}{ad(ad(nat)), ad(ItRed), ad(tupla(enConjunto: conj(paquete)\, porID: dicc$_{\text{AVL}}$, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))), paquete, ad(tupla(enConjunto: conj(paquete), porID: dicc\_AVL(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))), nat, nat}{secu(compu)}{} %AGREGAR RESTRICCION  

\tadAxioma{caminoDelPaquete$_{\text{aux}}$($t$, $CsxID$, $ps$, $p$, $Psr$, $compuActual$, $d$)}{\IF def?(ID($p$), porID($ps$[$compuActual$])) THEN siguiente($CsxID$[$compuActual$]) $\puntito$ <> ELSE siguiente($CsxID$[$compuActual$]) $\puntito$ caminoDelPaquete$_{\text{aux}}$($t$, $CsxID$, $ps$, $p$, $Psr$, $t$[$compuActual$][$d$], $d$) FI}

  ~

\tadOperacion{finAd}{ad(tupla(enConjunto: conj(paquete), porID: dicc$_{\text{AVL}}$(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))))}{ad(tupla(enConjunto: conj(paquete), porID: dicc\_AVL(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))))}{} 

\tadAxioma{finAd($a$)}{\IF (tam(a) $\leq$ 1) THEN crearArreglo(0) ELSE finAd$_{\text{aux}}$(a, crearArreglo(tam(a)-1), tam(a)-2) FI}

  ~

\tadOperacion{finAd$_{\text{aux}}$}{ad(tupla(enConjunto: conj(paquete), porID: dicc$_{\text{AVL}}$(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))))/a, ad(tupla(enConjunto: conj(paquete), porID: dicc$_{\text{AVL}}$(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))))/b, nat}{ad(tupla(enConjunto: conj(paquete), porID: dicc$_{\text{AVL}}$(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))))}{tam(a)>1 $\land$ tam(b)>0}

\tadAxioma{finAd$_{\text{aux}}$($a$, $b$, $n$)}{\IF ($n$=0) THEN $b$[0] $\leftarrow$ $a$[1] ELSE finAd$_{\text{aux}}$($a$, $b$[n]$\leftarrow$ $a$[$n$+1], $n$ -1) FI}

 % aca estoy poniendo los axiomas de las funciones que use en el rep
  \tadOperacion{juntarColaPriorEnConj}{colaPrior(tupla<prioridad{,} ItConj(paquete)>)}{conj(tupla<prioridad{,} ItConj(paquete)>)}{}
  \tadAxioma{juntarColaPriorEnConj(c)}{\IF vacia?(c) THEN $\emptyset$ ELSE ag(proximo(c), juntarColaPriorEnConj(desencolar(c))) FI}
  
  \tadOperacion{dame$\Pi_{2}$}{conj(tupla<prioridad, ItConj(paquete)>)}{conj(ItConj(paquete))}{}
  \tadAxioma{dame$\Pi_{2}$(c)}{\IF $\emptyset$?(c) THEN $\emptyset$ ELSE ag($\Pi_{2}$(dameuno(c)), dame$\Pi_{2}$(sinuno(c))) FI}
  
  \tadOperacion{dameSiguientes}{conj(ItConj(paquete))}{conj(paquete)}{restricciones}
  \tadAxioma{dameSiguientes(c)}{\IF $\emptyset$?(c) THEN $\emptyset$ ELSE ag(siguiente(dameuno(c)), dameSiguientes(sinuno(c))) FI}

\end{Representacion}

\begin{Algoritmos}

  \begin{algoritmo}{iIniciarDCNet}{\In{r}{Red}}{DCNet}
    $res \gets$ iCopiar($r$)\com*{$\Theta(n \times I)$}   
    $res$.\#PaqEnviados $\gets$ crearArreglo(cantCompus($res$.red))\com*{$\Theta(n)$}   
    $res$.IPsCompuPorID $\gets$ crearArreglo(cantCompus($res$.red))\com*{$\Theta(n)$}   
    $res$.siguientesCompus $\gets$ crearArreglo(cantCompus($res$.red))\com*{$\Theta(n)$}   
    $res$.paquetesEnEspera $\gets$ crearArreglo(cantCompus($res$.red))\com*{$\Theta(n)$}   
    \tipo{itRed} $it_{0} \gets$ crearItRed($res$.red)\com*{$\Theta(1)$}   
    \tipo{nat} $j \gets$ 0\com*{$\Theta(1)$}   
    \While(\com*[f]{$\Theta(n)$}){$j$ < Cardinal(Computadoras($res$.red))}{
      $res$.siguientesCompus[$j$] $\gets$ crearArreglo(cantCompus($res$.red))\com*{$\Theta(n)$}   
      $res$.\#PaqEnviados[$j$] $\gets$ 0\com*{$\Theta(1)$}   
      $res$.paquetesEnEspera[$j$] $\gets$ $\langle$vac\'{i}o(),vac\'{i}o(),vac\'{i}o()$\rangle$\com*{$\Theta(1)$}   
      definir(siguiente($it_{0}$).IP, $j$, $res$.IDsCompusPorIP)\com*{$\Theta(L+I^2)$}   
      $res$.IPsCompusPorID[$j$] $\gets$ $it_{1}$\com*{$\Theta(1)$}   
      $j \gets j + 1$\com*{$\Theta(1)$}   
      avanzar($it_{1}$)\com*{$\Theta(1)$}   
    }
    \tipo{nat} $k \gets$ 0\com*{$\Theta(1)$}   
    $j \gets 0$\com*{$\Theta(1)$}   
    \While(\com*[f]{$\Theta(n)$}){$j$ < Cardinal(Computadoras($res$.red))}{
      \While(\com*[f]{$\Theta(n)$}){$k$ < Cardinal(Computadoras($res$.red))}{
        \If(\com*[f]{$\Theta(n+I)$}){conectadas?($res$.red, siguiente($res$.IPsCompusPorID[j]), siguiente($res$.IPsCompusPorID[k]))}{
          \tipo{itConj} $it_{0} \gets$ crearIt(caminosMinimos($res$.red, siguiente($res$.IPsCompusPorID[j]), siguiente($res$.IPsCompusPorID[k])))\;
          $res$.siguientesCompus[$j$][$k$] $\gets$ prim(fin(siguiente($it_{1}$)))\com*{$\Theta(1)$}   
        }
        $k \gets k + 1$\com*{$\Theta(1)$}  
      }
      $j \gets j + 1$\com*{$\Theta(1)$}  
    }
  \end{algoritmo}
 \datosAlgoritmo{} % DescripciÃ³n
  {} % Pre
  {} % Post
  {$\Theta(n \times I + 4 n + n \times (n + I^2 + L) + n \times (n \times (n + I + camMin)))$ = $\Theta(n \times I + n + n^2+ n \times I^2 + n \times L + n^3 + n^2 \times I + camMin)$ que esta incluido en $\Theta(n^3 \times I^2 \times L + camMin)$} % Complejidad
  {} % JustificacÃ­Ã³n


  \begin{algoritmo}{iCrearPaquete}{\Inout{d}{DCNet},\In{p}{paquete}}{}
    % Crear e inicializar variables:
    \tipo{nat} $o \gets$ iObtener($p$.origen, $d$.IDsCompusPorIP)\com*{$\Theta(L)$}
    \tipo{nat} $dest \gets$ iObtener($p$.destino, $d$.IDsCompusPorIP)\com*{$\Theta(L)$}
    $it \gets$ CrearIt(($d$.paquetesEnEspera[$o$]).enConjunto)\com*{$\Theta(1)$}
    $it \gets$ Agregar(($d$.paquetesEnEspeta[$o$]).enConjunto, $p$)\com*{$\Theta(k)$}
    Definir($d$.paquetesEnEspera[$o$].porID, $p$.ID, $\langle$ $it$, $o$, $dest$, $\rangle$)\com*{$\Theta(log(k))$}
    encolar($d$.paquetesEnEspera[$o$].porPrioridad, $p$.prioridad, $it$)\com*{$\Theta(log(k))$}
    \end{algoritmo}
  \datosAlgoritmo{} % DescripciÃ³n
  {} % Pre
  {} % Post
  {$\Theta(L+log(k))$} % Complejidad
  {} % JustificacÃ­Ã³n

  \begin{algoritmo}{iRed}{\In{d}{DCNet}}{Red}
    $res \gets$ $d$.Red \com*{$\Theta(1)$}
  \end{algoritmo}

  \begin{algoritmo}{iAvanzarSegundo}{\Inout{d}{DCNet}}{}
    \tipo{nat} $j \gets 0$\com*{$\Theta(1)$}
    \tipo{nat} $o$\com*{$\Theta(1)$}
    \tipo{nat} $dest$\com*{$\Theta(1)$}
    \tipo{paquete} $paq$\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$}){$j$ < Cardinal(Computadoras($d$.red))}{
      \If(\com*[f]{$\Theta(1)$}){!(EsVacio?($d$.paquetesEnEspera[$j$]).enConjunto)}{
        $paq \gets$ Siguiente(desencolar(($d$.paquetesEnEspera[$j$]).porPrioridad))\com*{$\Theta(log(k))$}
        $o \gets$ (Obtener(($d$.paquetesEnEspera[$j$]).porID, $paq$.ID)).codOrigen\com*{$\Theta(log(k))$}
        $dest \gets$ (Obtener(($d$.paquetesEnEspera[$j$]).porID, $paq$.ID)).codDestino\com*{$\Theta(log(k))$}
        $i \gets$ (Obtener(($d$.paquetesEnEspera[$j$]).porID, $paq$.ID)).iPaquete\com*{$\Theta(log(k))$}
        Borrar(($d$.paquetesEnEspera[$j$]).porID, $paq$.ID)\com*{$\Theta(log(k))$}
        EliminarSiguiente(i)\com*{$\Theta(log(1))$}
        $d$.\#paqEnviados[$j$]++\com*{$\Theta(1)$}
        \If(\com*[f]{$\Theta(1)$}){!($d$.siquienteCompu[$j$][$dest$] = $dest$)}{
          $it \gets$ crearIt($d$.paquetesEnEspera[$d$.siguienteCompu[$j$][$dest$]])\com*{$\Theta(1)$}
          $it \gets$ AgregarRapido(($d$.paquetesEnEspera[$d$.siguienteCompu[$j$][$dest$]]).enConjunto, $p$)\com*{$\Theta(I)$ lo tomamos como $\Theta(1)$}
          Definir($d$.paquetesEnEspera[$d$.siguienteCompu[$j$][$dest$]].porID, $p$.ID, $\langle$ $it$, $d$.siguienteCompu[$j$][$dest$], $dest$, $\rangle$)\com*{$\Theta(log(k))$}
          encolar($d$.paquetesEnEspera[$d$.siguienteCompu[$j$][$dest$]].porPrioridad, $paq$.prioridad, $it$)\com*{$\Theta(log(k))$}
        }
      }
    }
    \tipo{nat} $k \gets 0$\com*{$\Theta(1)$}
    \tipo{nat} $h \gets 0$\com*{$\Theta(1)$}
    \If(\com*[f]{$\Theta(1)$}){Cardinal(Computadoras($d$.red))>0}{
      \While(\com*[f]{$\Theta(n)$ iteraciones}){k<Cardinal(Computadoras($d$.red))}{
        \If(\com*[f]{$\Theta(1)$}){$d$.\#paqEnviados[$k$]>d.\#paqEnviados[h]}{
          $h \gets k$\com*{$\Theta(1)$}
          k++\com*{$\Theta(1)$}
        }
      }
    }
    $d$.laQueM\'asEnvi\'o $\gets$ $d$.IPsCompusPorID[h]\com*{$\Theta(1)$}
  \end{algoritmo}
 \datosAlgoritmo{} % DescripciÃ³n
  {} % Pre
  {} % Post
  {\com*{$\Theta(n \times log(k))$ esta incluido en \com*{$\Theta(n \times (L+log(k)+log(n))$}}} % Complejidad
  {} % JustificacÃ­Ã³n


  \begin{algoritmo}{iCaminoRecorrido}{\In{d}{DCNet}, \In{p}{paquete}}{lista(compu)}
    \tipo{nat} $j \gets 0$\com*{$\Theta(1)$}
    $res \gets$ iVacia()\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(log(k))$ iteraciones}){!(iDefinido?(($d$.paquetesEnEspera[$j$]).porID), $p$.ID)}{
      $j$++\com*{$\Theta(1)$}
    }
    \tipo{nat} $o$\com*{$\Theta(1)$}
    $o \gets$ (Obtener(($d$.paquetesEnEspera[$j$]).porID, $p$.ID)).codOrigen\com*{$\Theta(log(k))$}
    \tipo{nat} $dest$\com*{$\Theta(1)$}
    $dest \gets$ (Obtener(($d$.paquetesEnEspera[$o$]).porID, $p$.ID)).codDestino\com*{$\Theta(log(k)$}
    \While(\com*[f]{$\Theta(n \times log(k))$}){!(Definido?(($d$.paquetesEnEspera[$o$]).porID), $p$.ID)}{
      iAgregarAtras($res$, siguiente($d$.IPsCompusPorID[0]))\com*{$\Theta(I)$ lo tomamos como $\Theta(1)$}
      $o \gets$ $d$.siguientesCompus[o][dest]\com*{$\Theta(1)$}
    }
    AgregarAtras($res$, siguiente($d$.IPsCompusPorID[$o$]))\com*{$\Theta(I)$ lo tomamos como $\Theta(1)$}
  \end{algoritmo} 
  \datosAlgoritmo{} % DescripciÃ³n
  {} % Pre
  {} % Post
  {$\Theta(n \times log(k))$} % Complejidad
  {} % JustificacÃ­Ã³n

  \begin{algoritmo}{iCantidadEnviados}{\In{d}{DCNet}, \In{c}{compu}}{nat}
    \tipo{nat} $i \gets$ Obtener($d$.IDsCompusPorIP, $c$.IP)\com*{$\Theta(L)$}
    $res \gets$ $d$.\#paqEnviados[i]\com*{$\Theta(1)$}
  \end{algoritmo}
 \datosAlgoritmo{} % DescripciÃ³n
  {} % Pre
  {} % Post
  {$\Theta(L)$} % Complejidad
  {} % JustificacÃ­Ã³n

  \begin{algoritmo}{iEnEspera}{\In{d}{DCNet}, \In{c}{compu}}{conj(Paquete)}
    \tipo{nat} $i \gets$ iObtener($d$.IDsCompusPorIP, $c$.IP)\com*{$\Theta(L)$}
    $res \gets$ ($d$.paquetesEnEspera[i]).enConjunto\com*{$\Theta(1)$}
  \end{algoritmo}
 \datosAlgoritmo{} % DescripciÃ³n
  {} % Pre
  {} % Post
  {$\Theta(L)$} % Complejidad
  {} % JustificacÃ­Ã³n

  \begin{algoritmo}{ilaQueM\'{a}sEnvio}{\In{d}{DCNet}}{compu}
    $res \gets$ siguiente($d$.laQueM\'{a}sEnvio)\com*{$\Theta(I)$ lo tomamos como \com*{$\Theta(1)$} ya que, copiar una computadora o devolver el siguiente de un iterador a computadora es $\Theta(I)$ }
  \end{algoritmo}
  \datosAlgoritmo{} % DescripciÃ³n
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % JustificacÃ­Ã³n

  \begin{algoritmo}{paquetesEntr\'{a}nsito?}{\In{d}{DCNet}}{conj(paquete)}
    $res \gets$ false \com*{$\Theta(1)$}
    \tipo{nat} $i \gets 0$\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$}){$i$<longitud($d$.paquetesEnEspera)}{
      \If(\com*[f]{$\Theta(log(k))$}){definido?($p$, ($d$.paquetesEnEspera[$i$]).porID)}{
          $res \gets$ true\com*{$\Theta(1)$}
      }
    }
  \end{algoritmo}
  \datosAlgoritmo{} % DescripciÃ³n
  {} % Pre
  {} % Post
  {$\Theta(n \times log(k))$} % Complejidad
  {} % JustificacÃ­Ã³n

\end{Algoritmos}

