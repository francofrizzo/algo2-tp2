\section{M\'odulo DCNet}

\begin{Interfaz}
  
  \textbf{se explica con:} \tadNombre{DCNet}
  
  \textbf{g\'eneros:} \TipoVariable{dcnet}
  
  \Titulo{Operaciones b\'asicas de lista}

  \InterfazFuncion{iniciarDCNet}{\In{r}{Red}}{DCNet}%
  [true]%pre
  {res $\igobs$ iniciarDCNet(r)}%pos
  [$\Theta(1234)$]%complejidad
  [Genera un nuevo DCNet sin paquetes. ``vac\'ia'' ]%descripcion
  []%aliasing
  
  \InterfazFuncion{crearPaquete}{\Inout{D}{DCNet}, \In{p}{paquete}}{}%
  [D $\igobs$ $D_{0}$ $\land$ $\not$(($\exists p'$: paquete)(paqueteEnTransito?(D,p') $\land$ id(p') = id(p)) $\land$ origen(p) $\in$ computadoras(red(D)) $\yluego$ destino(p) $\in$ computadoras(red(D)) $\yluego$ hayCamino?(red(D), origen(p), destino(p)))]%pre
  {D $\igobs$ crearPaquete($D_{0}$, p)}%pos
  [$\Theta(l+log(k))$]%complejidad
  [Crea un nuevo paquete que no exite en el DCNet anterior. ]%descripcion
  []%aliasing

  \InterfazFuncion{avanzarSegundo}{\Inout{D}{DCNet}}{}%
  [D $\igobs$ $D_{0}$]%pre
  {D $\igobs$ avanzarSegundo($D_{0}$)}%pos
  [$\Theta(n.(L+log(n)+log(k)))$]%complejidad
  [Avanza un segundo en el DCNet, moviendo todos los paquetes correspondientes. ]%descripcion
  []%aliasing

  \InterfazFuncion{red}{\In{D}{DCNet}}{red}%
  [true]%pre
  {res $\igobs$ red(D)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve la red donde esta funcionando el DCNet. ]%descripcion
  []%aliasing

  \InterfazFuncion{caminoRecorido}{\In{D}{DCNet}, \In{p}{paquete}}{secu(compu)}%
  [paqueteEnTrancito?(D, p)]%pre
  {res $\igobs$ caminoRecorrido(D, p)}%pos
  [$\Theta(n.log(max(n,k)))$]%complejidad
  [Devuelve la secuencia que contiene de forma ordenada todas las computadoras por las que fue pasando. ]%descripcion
  []%aliasing

  \InterfazFuncion{cantidadEnviados}{\In{D}{DCNet}, \In{c}{compu}}{nat}%
  [c $\in$ computadoras(red(D))]%pre
  {res $\igobs$ cantidadEnviados(D, c)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve la cantidad de paquetes que envi\'o la computadora ``c''. ]%descripcion
  []%aliasing

  \InterfazFuncion{enEspera}{\In{D}{DCNet}, \In{c}{compu}}{conj(paquete)}%
  [c $\in$ computadoras(red(D))]%pre
  {res $\igobs$ enEspera(D, c)}%pos
  [$\Theta(L)$]%complejidad
  [Devuelve los paquetes que tiene en espera la compu ``c''. ]%descripcion
  []%aliasing

  \InterfazFuncion{paquetesEnEspera?}{\In{D}{DCNet}, \In{p}{paquete}}{bool}%
  [true]%pre
  {res $\igobs$ paquetesEnTrancito?(D, p)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve ``True'' si y solo si el paquete esta en los paquetes en espera de alguna computadora. ]%descripcion
  []%aliasing

  \InterfazFuncion{laQueMasEnvio}{\In{D}{DCNet}}{compu}%
  [true]%pre
  {res $\igobs$ laQueMasEnvio(D)}%pos
  [$\Theta(1)$]%complejidad
  [Devuelve una de las computadoras con mas paquetes enviados]%descripcion
  []%aliasing

  \InterfazFuncion{NOMBRE}{PARAMTROS}{RES}%
  []%pre
  {}%pos
  []%complejidad
  []%descripcion
  []%aliasing

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{dcnet}[estrDCNet]

    \begin{Tupla}[estrDCNet]
      \tupItem{red}{red}
      \tupItem{IDsCompusPorIP}{dicc\_trie(string, nat)}
      \tupItem{siguientesCompus}{ad(ad(nat))}
      \tupItem{paquetesEnEspera}{ad(tupla(enConjunto: conj(paquete), porID: dicc\_AVL(ID, tupla(iPaquete: itConj(paquete),codOrigen: nat, codDestino: nat), porPrioridad: heap(tupla(prioridad, itConjunto(paquete))))))}
      \tupItem{\#PaqEnviados}{ad(nat)}
      \tupItem{laQueM\'asEnvi\'o}{itRed}
      \tupItem{IPsCompuPorID}{ad(itRed)}
    \end{Tupla}

  \end{Estructura} 

	\Rep[e][l]{
	($\forall e$: estr)(

%1
		(tam(e.paquetesEnEspera) = tam(e.IPcompusXID) = tam(e.siguienteCompu) = tam (e.cantPaquetesEnviados) = \#(computaodras(e.estrRed))) $\land$ 
		($\forall n$: nat)(definido?(e.siguienteCompu,n) $\impluego$ tam(e.siguienteCompu[n]) = \#(computadoras(e.estrRed))) $\land$

%2
		Maximo(e.cantPaqEnviados) = e.cantidadEnviados[obtener($\pi_1$(siguiente(e.laQueMasEnvio)),e.IDcompusPorIP)] $\land$

%3 CHEQUEAR PARENTESIS
		($\forall c$: compu)(c $\in$ computadoras(e.estRed) $\impluego$ obtener($\pi_1$(c),e.IDcompusPorIP) < \#(computadoras(e.estrRed))) $\land$
		(($\forall c_1$, $c_2$: compu)(($c_1 \in$ computadoras(e.estRed) $\land$ ($c_2 \in$ computadoras(e.estrRed)) $\land$ ($c_1 \neq c_2$)) $\impluego$ ((obtener($\pi_1$($c_1$), e.IDcompusPorIP) $\neq$ obtener($\pi_1$($c_2$), e.IDcompusPorIP))))) $\land$

%4
		(dameNombres(computadoras(e.estrRed)) = claus(IDcompusPorIP)) $\land$

%5
		($\forall L$: nat)( 0 $\leq$ L < tam(e.paqEnEspera) $\impluego$ (

      ($\forall$ $it_1$: ItConj(paquete)) $it$ $\in$ dame$\pi_1$(juntarSignificado($\pi_2$(e.paquetesEnEspera[L]))) $\impluego$ haySiguiente?($it_1$) $\land$
      ($\forall$ $it_2$: ITconj(pauqete)) $it_2$ $\in$ dame$pi_2$(juntarColaEnConjunto($\pi_3$(e.paquetesEnEspera[L]))) $\impluego$ haySiguiente?($it_2$) $\yluego$ 

			($\forall i$: ItConj(paquete))(siguiente(i) $\in$ (dameSiguientes(dame$\pi_1$($juntarSignificados_1$($\pi_2$(e.paquetesEnEspera[L])))$\impluego$ siguiente(i) $\in \pi_1$(e.paquetesEnEspera[L])))) $\land$ 
			($\forall c$: ID)(c$\in$ claves($\pi_2$(e.paquetesEnEspera[L])) $\impluego \pi_1$(siguiente($\pi_1$(obtener($\pi_2$(c), e.paquetesEnEspera[L])))) = c) $\land$
      ($\forall$ $it$:ItConj(paquete)) siguiente($it$) $\in$ dameSiguientes(dame$\pi_2$(juntarColaPrioriEnConj($\pi_3$(e.paquetesEnEspera[L])))) $\impluego$ siguiente($it$) $\in$ $\pi_1$(e.paquetesEnEspera[L])
			($\forall$ $t$: tupla <prioridad,ItConj(paquete)>) $t$ $\in$ juntarColaPrioriEnConj($\pi_3$(e.paquetesEnEspera[L])) $\rightarrow$ siguiente($\pi_2$($t$)).prioridad = $\pi_1$($t$)

% *1
    ($\forall x$, $z$: nat)((0 $\leq$ x < tam(e.paquetesEnEspera) $\land$ 0 $\leq$ z < tam(e.paquetesEnEspera) $\land$ x $\neq$ z) $\impluego$ ($\pi_1$(e.paquetesEnEspera[x]) $\cap$ $\pi_2$(e.paquetesEnEspera[z])) = $\emptyset$) $\land$

%6
		($\forall i$: nat)(0 $\leq$ i < \#(computadoras(e.estrRed)) $\land$ obtener($\pi_1$(siguiente(e.IPcompusPorID[i])), e.IDcompusPorID) = i) $\land$

%7
		($\forall n$, $m$: nat)(0 $\leq$ n < \#(computadoras(e.estrRed)) $\land$ 0 $\leq$ n < \#(computadoras(e.estrRed)) $\impluego$ ($\exists$ $x$: (secu(compu))) $x$ $\in$ caminosminimos(e.estrRed, siguiente(e.IPcompusPorID[n]), siguiente(e.IPcompusPorID[m])) $\land$ prim($x$) $=$ e.siguienteCompu[n][m] 

%8
    ($\forall i$: nat)(0 $\leq$ i $\leq$ \#computadoras(e.estrRed) $\impluego$ siguiente(e.IPcompusPorID[i]) $\in$ compitadoras(e.estrRed)) $\land$

% *2
    ($\forall x$, $y$: nat)((0 $\leq$ x < \#computadoras(e.estrRed) $\land$ 0 $\leq$ y < \#computadoras(e.estrRed) $\land$ x $\neq$ y) $\impluego$ (siguiente(e.IPcompusPorID[x]) $\neq$ siguiente(e.IPcompusPorID[y]))))) $\land$

%9
    \#($\pi_1$(e.paquetesEnEspera)) = \#claves($\pi_2$(e.paquetesEnEspera)) $\land$ = \#(juntarSecuenciasEnConj(juntarSignificados($\pi_3$(e.paquetesEnEspera)))) $\land$

%10
    ($\forall$ $\it_{1}$: ItConj(paquete)) ($\forall$ $\it_{2}$: ItConj(paquete)) $\it_{1}$ $\in$ dame$\pi_{2}$(juntarColaPriorEnConj($\pi_{3}$(e.paquetesEnEspera[L]))) $\land$ $\it_{2}$ $\in$ dame$\pi_{2}$(juntarColaPriorEnConj($\pi_{3}$(e.paquetesEnEspera[L]))) $\it_{1}$ $\neq$ $\it_{2}$ $\impluego$ siguiente($\it_{1}$) $\neq$ siguiente($\it_{2}$)
    }\mbox{} %habia un parentesis no se de donde sale (estaba cerrando en esta linea)

\AbsFc[estrDCNet]{DCNet}[e]{red($d$) = e.estrRed $\land$ \\

  ($\forall p$: paquete) paqueteEnTr\'ansito?($d$, $p$) $\impluego$ caminoRecorrido($d$, $p$) = caminoDelPaquete(e.siguienteCompu, e.IPsCompusPorID, e.PaquetesEnEspera, $p$) $\land$ \\

  ($\forall c$: compu) $c$ $\in$ computadoras(red($d$)) $\impluego$ cantidadEnviados($d$, $c$) = e.\#PaqEnviados[obtener($c$, e.IDsCompusPorIP)] $\land$ \\

  ($\forall c$: compu) $c$ $\in$ computadoras(red($d$)) $\impluego$ enEspera($d$, $c$) = enConjunto(e.paquetesEnEspera[obtener($c$, e.IDsCompusPorIP)])
}

  ~      

\tadOperacion{caminoDelPaquete}{ad(ad(nat)), ad(ItRed), ad(tupla(enConjunto: conj(paquete), porID: dicc$_{\text{AVL}}$(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))), paquete, ad(tupla(enConjunto: conj(paquete), porID: dicc\_AVL(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete))))))}{secu(compu)}{} %FALTA AGREGAR RESTRICCION y alinear bien los parametros - Manu  

\tadAxioma{caminoDelPaquete($t$, $CsxID$, $ps$, $p$, $Psr$)}{\IF def?(ID($p$), porID($ps$[0])) THEN caminoDelPaquete$_{\text{aux}}$($t$, $CsxID$, $ps$, $p$, codOrigen(obtener(ID($p$), porId($ps$[0]))), codDestino(obtener(ID($p$), porId($ps$[0])))) ELSE caminoDelPaquete($t$, $CsxID$, $ps$, $p$, finAd(psr)) FI}

  ~

\tadOperacion{caminoDelPaquete$_{\text{aux}}$}{ad(ad(nat)), ad(ItRed), ad(tupla(enConjunto: conj(paquete)\, porID: dicc$_{\text{AVL}}$, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))), paquete, ad(tupla(enConjunto: conj(paquete), porID: dicc\_AVL(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))), nat, nat}{secu(compu)}{} %AGREGAR RESTRICCION  

\tadAxioma{caminoDelPaquete$_{\text{aux}}$($t$, $CsxID$, $ps$, $p$, $Psr$, $compuActual$, $d$)}{\IF def?(ID($p$), porID($ps$[$compuActual$])) THEN siguiente($CsxID$[$compuActual$]) $\puntito$ <> ELSE siguiente($CsxID$[$compuActual$]) $\puntito$ caminoDelPaquete$_{\text{aux}}$($t$, $CsxID$, $ps$, $p$, $Psr$, $t$[$compuActual$][$d$], $d$) FI}

  ~

\tadOperacion{finAd}{ad(tupla(enConjunto: conj(paquete), porID: dicc$_{\text{AVL}}$(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))))}{ad(tupla(enConjunto: conj(paquete), porID: dicc\_AVL(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))))}{} 

\tadAxioma{finAd($a$)}{\IF (tam(a) $\leq$ 1) THEN crearArreglo(0) ELSE finAd$_{\text{aux}}$(a, crearArreglo(tam(a)-1), tam(a)-2) FI}

  ~

\tadOperacion{finAd$_{\text{aux}}$}{ad(tupla(enConjunto: conj(paquete), porID: dicc$_{\text{AVL}}$(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))))/a, ad(tupla(enConjunto: conj(paquete), porID: dicc$_{\text{AVL}}$(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))))/b, nat}{ad(tupla(enConjunto: conj(paquete), porID: dicc$_{\text{AVL}}$(ID\, tupla(iPaquete: itConj(paquete)\,codOrigen: nat\, codDestino: nat\, porPrioridad: heap(tupla(prioridad\, itConjunto(paquete)))))))}{tam(a)>1 $\land$ tam(b)>0}

\tadAxioma{finAd$_{\text{aux}}$($a$, $b$, $n$)}{\IF ($n$=0) THEN $b$[0] $\leftarrow$ $a$[1] ELSE finAd$_{\text{aux}}$($a$, $b$[n]$\leftarrow$ $a$[$n$+1], $n$ -1) FI}

 % aca estoy poniendo los axiomas de las funciones que use en el rep
  \tadOperacion{juntarColaPriorEnConj}{colaPrior(tupla<prioridad{,} ItConj(paquete)>)}{conj(tupla<prioridad{,} ItConj(paquete)>)}{}
  \tadAxioma{juntarColaPriorEnConj(c)}{\IF vacia?(c) THEN $\emptyset$ ELSE ag(proximo(c), juntarColaPriorEnConj(desencolar(c))) FI}
  
  \tadOperacion{dame$\pi_{2}$}{conj(tupla<prioridad, ItConj(paquete)>)}{conj(ItConj(paquete))}{}
  \tadAxioma{dame$\pi_{2}$(c)}{\IF $\emptyset$?(c) THEN $\emptyset$ ELSE ag($\pi_{2}$(dameuno(c)), dame$\pi_{2}$(sinuno(c))) FI}
  
  \tadOperacion{dameSiguientes}{conj(ItConj(paquete))}{conj(paquete)}{restricciones}
  \tadAxioma{dameSiguientes(c)}{\IF $\emptyset$?(c) THEN $\emptyset$ ELSE ag(siguiente(dameuno(c)), dameSiguientes(sinuno(c))) FI}

\end{Representacion}

