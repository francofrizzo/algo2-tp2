\section{M\'{o}dulo Heap($\alpha$)}

\begin{Interfaz}
  
  \begin{paramFormales}
    \paramGeneros{$\alpha$}

    \paramFuncion{
      \InterfazFuncion{$\bullet \leq \bullet$}{\In{a_{1}}{$\alpha$}, \In{a_{a}}{$\alpha$}}{bool}
      {$res \igobs (a_{1} \leq a_{2})$}
      [$\Theta(compare(a_{1}, a_{2}))$]
      [funci\'on de comparaci\'on por orden total estricto de $\alpha$]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
      {$res \igobs a$}
      [$\Theta(copy(a))$]
      [funci\'{o}n de copia de $\alpha$]
    }

  \end{paramFormales}

  \seExplicaCon{Cola de Prioridad($\alpha$)}

  \generos{\tipo{heap($\alpha$)}}

  \Encabezado{Operaciones de cola de prioridad}

    \InterfazFuncion{vac\'{i}o}{}{heap($\alpha$)}
    [true]
    {$res \igobs$ vac\'{i}o}
    [$\Theta(1)$]
    [Devuelve un heap vac\'io.]

    \InterfazFuncion{encolar}{\Inout{h}{heap($\alpha$)}, \In{a}{$\alpha$}}{}{}
    [$h \igobs h_{0}$]
    {$h \igobs$ encolar($a$, $h_{0}$)}
    [$\Theta(log(n))$]
    [Agrega un elemento al heap.]

    \InterfazFuncion{vac\'{i}o?}{\In{h}{heap($\alpha$)}}{bool}
    [true]
    {$h \igobs$ vac\'{i}o()}
    [$\Theta(1)$]
    [Devuelve true si y solo si el heap no tiene elementos.]

    \InterfazFuncion{desencolar}{\Inout{h}{heap($alpha$)}}{}
    [$\not$(vac\'ia?(h))]
    {$res \igobs$ desencolar(h)}
    [$\Theta(log(n))$]
    [Devuelve uno de los elementos de m\'axima prioridad del heap, y lo elimina de la estructura.]

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{heap($\alpha$)}[vector($\alpha$)]
  \end{Estructura} 

  \Rep[vector($\alpha$)][v]{
    ($\paratodo{i}{nat}$) ((($2 \* i < $long($v$)) $\impluego$ i\'esimo($2 \* i$, $v$) $\leq$ i\'esimo($i$, $v$)) $\land$ (($2 \* i + 1< $long($v$)) $\impluego$ i\'esimo($2 \* i + 1$, $v$) $\leq$ i\'esimo($i$, $v$)))
  }

  \tadOperacion{i\'esimo}{nat/$i$,secu($\alpha$/$s$)}{$\alpha$}{$n \leq long($\alpha$)$}  

  \tadAxioma{i\'esimo($i$, $s$)}{\IF $i = 0$ THEN prim($s$) ELSE i\'esimo($i - 1$, fin($s$)) FI}

  \AbsFc[vector($\alpha$)]{colaPrior($\alpha$)}[v]{
    \IF long($v$) = 0 THEN vac\'{i}a() ELSE encolar(prim($v$), Abs(fin($v$))) FI
  }

\end{Representacion}

\begin{Algoritmos}

  \begin{algoritmo}{iVacio}{}{vector($\alpha$)}
    $res \gets Vac\'ia()$ \;
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
<<<<<<< HEAD
  {} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iEncolar}{\Inout{hp}{heap($\alpha$)}, \In{a}{$\alpha$}}{}
    agregarAtras($v$, $a$) \;
    \tipo{nat} $i \gets $long$(v)$ \;
    \While{$i \neq 1 \land v[i] < v[i \text{ div } 2]$}{
      swap($v$, $i$, $i \text{ div } 2$) \;
      $i \gets i \text{ div } 2$ \;
=======
  {$\Theta(1)$} % Complejidad
  {La funci\'{o}n Vac\'{i}o() de vector es $\Theta(1)$ por ende Vac\'{i}o() de heap es $\Theta(1)$. } % Justificacíón

  \begin{algoritmo}{iEncolar}{\Inout{hp}{heap($\alpha$)}, \In{a}{$\alpha$}}{}
    $hp$.push\_back($a$)\; \com*{$\Theta(1)$}
    \tipo{nat} $i \gets$ $hp$.longitud - 1\; \com*{$\Theta(1)$}
    \tipo{nat} $p \gets$ (i/2) - ((i+1)\%2)\; \com*{$\Theta(1)$}
    \While{$hp$[$p$] < $hp$[$i$]}{ \com*{$\Theta(log(n))$}
      iSwap($hp$[$p$], $hp$[$i$])\; \com*{$\Theta(1)$}
      $i \gets p$\; \com*{$\Theta(1)$}
      $p \gets$ ($i$/2) - (($i$+1)\%2)\; \com*{$\Theta(1)$}
>>>>>>> b40f2acc88a534eb88c3d62491f28191f9a992c8
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
<<<<<<< HEAD
  {} % Complejidad
  {} % Justificación
=======
  {$\Theta(log(n))$} % Complejidad
  {El while se repite como maximo $log(n)$ veces, donde $n$ es la longitud del vector. } % Justificacíón

<<<<<<< HEAD
  \begin{algoritmo}{iVac\'{i}o?}{\In{hp}{heap($\alpha$)}}{bool}
    $res \gets$ ($hp$ = vac\'{i}o())\; \com*{$\Theta(1)$}
  \end{algoritmo}

  \begin{algoritmo}{iProximo}{\In{hp}{heap($\alpha$)}}{$\alpha$}
    $res \gets$ hp[0]\; \com*{$\Theta(1)$}
  \end{algoritmo}
>>>>>>> b40f2acc88a534eb88c3d62491f28191f9a992c8

  \begin{algoritmo}{iDesencolar}{\Inout{hp}{heap($\alpha$)}}{$\alpha$}
=======
  \begin{algoritmo}{iVac\'{i}o?}{\In{v}{vector($\alpha$)}}{bool}
    $res \gets$ esVac\'io?($v$) \;
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iDesencolar}{\Inout{v}{vector($\alpha$)}}{$\alpha$}
<<<<<<< HEAD
    $res \gets v[i]$ \;
    \tipo{nat} $v \gets 1$ \;
    \While{(($2i \leq$ long($v$)) $\land$ $v[i] < v[2i]$) $\lor$ ($2i + 1 \leq$ long($v$)) $\land$ $v[i] < v[2i + 1]$)}{
      \EIf{$2i + 1 \leq$ long($v$)}{
        \eIf{$v[i] < v[2i + 1]$}{
          swap($v$, $i$, $2i + 1$) \;
          $i \gets 2i + 1$ \;
        }{
          swap($v$, $i$, $2i$) \;
          $i \gets 2i$ \;
        }
      }{
        swap($v$, $i$, $2i$) \;
        $i \gets 2i$ \;
      }
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iSwap}{\Inout{v}{vector($\alpha$), Inout{i}{nat}, Inout{j}{nat}}}
    $\alpha aux \gets v[i]$ \;
    $v[i] \gets v[j]$ \;
    $v[j] \gets aux$ \;
=======
>>>>>>> d4eb108eb897a91487a4eaca8d13cb372707de4e

    \tipo{nat} $i \gets$ $hp$.longitud - 1\;
    iSwap($hp$[$0$], $hp$[$i$])\; \com*{$\Theta(1)$}
    $res \gets$ $hp$.pop\_back()\; \com*{$\Theta(1)$}

    \tipo{nat} $hijo_{0} \gets$ 1\; \com*{$\Theta(1)$}
    \tipo{nat} $hijo_{1} \gets$ 2\; \com*{$\Theta(1)$}
    \tipo{bool} $estaOrdenado \gets$ false\; \com*{$\Theta(1)$}

    \While{$\not$estaOrdenado}{ \com*{$\Theta(log(n))$}
      \eIf{$hijo_{0}$ < $hp$.longitud}{
        \eIf{$hijo_{1}$ < $hp$.longitud} {
          %//ambos hijos son validos
          \eIf{$hp$[$hijo_{0}$] $\geq$ $hp$[$hijo_{1}$]}{
            %//hijo0 es mas grande que hijo1
            \eIf{$hp$[$hijo_{0}$] > $hp$[$i$]}{
              %//hijo0 es mas grande que el padre -> los swapeo
              iSwap($hp$[$hijo_{0}$], $hp$[$i$])\; \com*{$\Theta(1)$}
              $i \gets hijo_{0}$\; \com*{$\Theta(1)$}
            }{
              %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
              $estaOrdenado \gets$ True\; \com*{$\Theta(1)$}
            }
          }{
            %//hijo1 es mas grande que hijo0
            \eIf{$hp$[$hijo_{1}$] > $hp$[$i$]}{
              %//hijo1 es mas grande que el padre -> los swapeo
              iSwap($hp$[$hijo_{1}$], $hp$[$i$])\; \com*{$\Theta(1)$}
              $i \gets hijo_{1}$\; \com*{$\Theta(1)$}
            }{
              %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
              $estaOrdenado \gets$ True\; \com*{$\Theta(1)$}
            }
          }
        }{
          %//solo hijo0 es valido
          \eIf{$hp$[$hijo_{0}$] > $hp$[$i$]} {
            %//hijo0 es mas grande que el padre -> los swapeo
            iSwap($hp$[$hijo_{0}$], $hp$[$i$])\; \com*{$\Theta(1)$}
            $i \gets hijo_{0}$\; \com*{$\Theta(1)$}
          }{
            %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
            $estaOrdenado \gets$ True\; \com*{$\Theta(1)$}
          }
        }
      }{
        %//ningun hijo es valido por ende no tiene hijos entonces esta ordenado
        $estaOrdenado \gets$ True\; \com*{$\Theta(1)$}
      }
      $hijo_{0} \gets$ 2x$i$+1\; \com*{$\Theta(1)$}
      $hijo_{1} \gets$ 2x$i$+2\; \com*{$\Theta(1)$}
    }
  \end{algoritmo}

  \begin{algoritmo}{iSwap}{\Inout{a}{$\alpha$}, \Inout{b}{$\alpha$}}{}
    \tipo{$\alpha$} $c$\; \com*{$\Theta(1)$}
    $c \gets a$\; \com*{$\Theta(1)$}
    $a \gets b$\; \com*{$\Theta(1)$}
    $b \gets c$\; \com*{$\Theta(1)$}
>>>>>>> b40f2acc88a534eb88c3d62491f28191f9a992c8
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificación

\end{Algoritmos}
