\section{M\'{o}dulo Heap($\alpha$)}

\begin{Interfaz}
  
  \begin{paramFormales}
    \paramGeneros{$\alpha$}

%    \paramFuncion{
%      \InterfazFuncion{$\bullet = \bullet$}{\In{a_{1}}{$\alpha$}, \In{a_{2}}{$\alpha$}}{bool}
%      {$res \igobs (a_{1} = a_{2})$}
%      [$\Theta(equal(a_{1}, a_{2}))$]
%      [funci\'on de igualdad de $\alpha$]
%    }

    \paramFuncion{
      \InterfazFuncion{$\bullet < \bullet$}{\In{a_{1}}{$\alpha$}, \In{a_{a}}{$\alpha$}}{bool}
      {$res \igobs (a_{1} \leq a_{2})$}
      [$\Theta(compare(a_{1}, a_{2}))$]
      [funci\'{o}n de comparaci\'{o}n de menor de $\alpha$. ] %Teniendo esta y la anterior, las siguientes funciones son triviales ("$\leq$", ">" y "$\geq$")]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
      {$res \igobs a$}
      [$\Theta(copy(a))$]
      [funci\'{o}n de copia de $\alpha$]
    }

  \end{paramFormales}

  \seExplicaCon{colaPrior($\alpha$)}

  \generos{heap($\alpha$)}

  \Encabezado{Operaciones del heap}

    \InterfazFuncion{vac\'{i}o}{}{heap($\alpha$)}
    [true]
    {$res \igobs$ vac\'{i}o}
    [$\Theta(1)$]
    [Constructor por defecto de heap($\alpha$)]

    \InterfazFuncion{encolar}{\Inout{h}{heap($\alpha$)}, \In{a}{$\alpha$}}{}{}
    [$h \igobs h_{0}$]
    {$h \igobs$ encolar($a$, $h_{0}$)}
    [$\Theta(log(h.longitud))$]
    [Agrega un elemento a la cola de prioridades]

    \InterfazFuncion{vac\'{i}o?}{\In{h}{heap($\alpha$)}}{bool}
    [true]
    {$h \igobs$ vac\'{i}o()}
    [$\Theta(1)$]
    [Devuelve true si y solo si h es un heap vac\'{i}o]

    \InterfazFuncion{pr\'{o}ximo}{\In{h}{heap($alpha$)}}{$\alpha$}
    [$\not$(vac\'ia?(h))]    % $\land$ $h_{0} \igobs h$]
    {$res \igobs$ pr\'{o}ximo (h)}
    [$\Theta(1)$]
    [Devuelve el pr\'{o}ximo elemento en el heap]

    \InterfazFuncion{desencolar}{\Inout{h}{heap($alpha$)}}{}
    [$\not$(vac\'ia?(h))]
    {$res \igobs$ desencolar(h)}
    [$\Theta(log(h.longitud))$]
    [Elimina el pr\'{o}ximo elemento en el heap]

    \InterfazFuncion{desencolar2}{\Inout{h}{heap($alpha$)}}{$\alpha$}
    [$h \igobs h_{0} \land \not$(vac\'ia?(h))]
    {$res \igobs$ pr\'{o}ximo($h_{0}$) $\land$ $h$ = desencolar($h_{0}$)}
    [$\Theta(log(h.longitud))$]
    [Elimina el pr\'{o}ximo elemento en el heap]

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{heap($\alpha$)}[vector($\alpha$)]
  \end{Estructura} 

  \Rep[heap($\alpha$)][hp]{
  
  %1) si A es el padre de B entonces A >= B
  %2) no hay ningun agujero en el vector es decir estan todos cargados consecutivos. por ende el arbol del heap se carga nivel a nivel de izq a der sin dejar ningun nivel con algun nodo sin hijos
  %3) si A es el padre de B entonces (A = hp[i]) entonces ((B=hp[2i+1]) xor (B=hp2i+2)) 
  %4) (es redundante pero creo que agrega mas claridad)
  %    si A es el padre de B entonces (A=hp[i]) entonces (A=hp[((i/2)-((i+1)%2)))])
  }

  \AbsFc[vector($\alpha$)]{colaPrior($\alpha$)}[h]{
    \IF h.long = 0 THEN vac\'{i}a() ELSE encolar(prim(h), ABS(fin(h))) FI
  }

\end{Representacion}

\begin{Algoritmos}

  \begin{algoritmo}{iVac\'{i}o}{}{heap($\alpha$)}
    $res \gets$ vector<$\alpha$>\;
  \end{algoritmo}

  \begin{algoritmo}{iEncolar}{\Inout{hp}{heap($\alpha$)}, \In{a}{$\alpha$}}{}
    $hp$.push\_back($a$)\;
    \tipo{nat} $i \gets$ $hp$.longitud - 1\;
    \tipo{nat} $p \gets$ (i/2) - ((i+1)\%2)\;
    \While{$hp$[$p$] < $hp$[$i$]}{
      iSwap($hp$[$p$], $hp$[$i$])\;
      $i \gets p$\;
      $p \gets$ ($i$/2) - (($i$+1)\%2)\;
    }
  \end{algoritmo}

  \begin{algoritmo}{iVac\'{i}o?}{\In{hp}{heap($\alpha$)}}{bool}
    $res \gets$ ($hp$ = vac\'{i}o())\;
  \end{algoritmo}

  \begin{algoritmo}{iProximo}{\In{hp}{heap($\alpha$)}}{$\alpha$}
    $res \gets$ hp[0]\;
  \end{algoritmo}

%  \begin{algoritmo}{iDesencolar}{\Inout{hp}{heap($\alpha$)}}{$\alpha$}
  \begin{algoritmo}{iDesencolar}{\Inout{hp}{heap($\alpha$)}}{}

    \tipo{nat} $i \gets$ $hp$.longitud - 1\;
    iSwap($hp$[$0$], $hp$[$i$])\;
%    $res \gets$ $hp$.pop\_back()\;
    $hp$.pop\_back()\;

    \tipo{nat} $hijo_{0} \gets$ 1\;
    \tipo{nat} $hijo_{1} \gets$ 2\;

    \While{$\not$estaOrdenado}{
      \eIf{$hijo_{0}$ < $hp$.longitud}{
        \eIf{$hijo_{1}$ < $hp$.longitud} {
          %//ambos hijos son validos
          \eIf{$hp$[$hijo_{0}$] $\geq$ $hp$[$hijo_{1}$]}{
            %//hijo0 es mas grande que hijo1
            \eIf{$hp$[$hijo_{0}$] > $hp$[$i$]}{
              %//hijo0 es mas grande que el padre -> los swapeo
              iSwap($hp$[$hijo_{0}$], $hp$[$i$])\;
              $i \gets hijo_{0}$\;
            }{
              %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
              $estaOrdenado \gets$ True\;
            }
          }{
            %//hijo1 es mas grande que hijo0
            \eIf{$hp$[$hijo_{1}$] > $hp$[$i$]}{
              %//hijo1 es mas grande que el padre -> los swapeo
              iSwap($hp$[$hijo_{1}$], $hp$[$i$])\;
              $i \gets hijo_{1}$\;
            }{
              %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
              $estaOrdenado \gets$ True\;
            }
          }
        }{
          %//solo hijo0 es valido
          \eIf{$hp$[$hijo_{0}$] > $hp$[$i$]} {
            %//hijo0 es mas grande que el padre -> los swapeo
            iSwap($hp$[$hijo_{0}$], $hp$[$i$])\;
            $i \gets hijo_{0}$\;
          }{
            %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
            $estaOrdenado \gets$ True\;
          }
        }
      }{
        %//ningun hijo es valido por ende no tiene hijos entonces esta ordenado
        $estaOrdenado \gets$ True\;
      }
      $hijo_{0} \gets$ 2x$i$+1\;
      $hijo_{1} \gets$ 2x$i$+2\;
    }
  \end{algoritmo}

  \begin{algoritmo}{iDesencolar2}{\Inout{hp}{heap($\alpha$)}}{$\alpha$}

    \tipo{nat} $i \gets$ $hp$.longitud - 1\;
    iSwap($hp$[$0$], $hp$[$i$])\;
    $res \gets$ $hp$.pop\_back()\;

    \tipo{nat} $hijo_{0} \gets$ 1\;
    \tipo{nat} $hijo_{1} \gets$ 2\;

    \While{$\not$estaOrdenado}{
      \eIf{$hijo_{0}$ < $hp$.longitud}{
        \eIf{$hijo_{1}$ < $hp$.longitud} {
          %//ambos hijos son validos
          \eIf{$hp$[$hijo_{0}$] $\geq$ $hp$[$hijo_{1}$]}{
            %//hijo0 es mas grande que hijo1
            \eIf{$hp$[$hijo_{0}$] > $hp$[$i$]}{
              %//hijo0 es mas grande que el padre -> los swapeo
              iSwap($hp$[$hijo_{0}$], $hp$[$i$])\;
              $i \gets hijo_{0}$\;
            }{
              %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
              $estaOrdenado \gets$ True\;
            }
          }{
            %//hijo1 es mas grande que hijo0
            \eIf{$hp$[$hijo_{1}$] > $hp$[$i$]}{
              %//hijo1 es mas grande que el padre -> los swapeo
              iSwap($hp$[$hijo_{1}$], $hp$[$i$])\;
              $i \gets hijo_{1}$\;
            }{
              %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
              $estaOrdenado \gets$ True\;
            }
          }
        }{
          %//solo hijo0 es valido
          \eIf{$hp$[$hijo_{0}$] > $hp$[$i$]} {
            %//hijo0 es mas grande que el padre -> los swapeo
            iSwap($hp$[$hijo_{0}$], $hp$[$i$])\;
            $i \gets hijo_{0}$\;
          }{
            %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
            $estaOrdenado \gets$ True\;
          }
        }
      }{
        %//ningun hijo es valido por ende no tiene hijos entonces esta ordenado
        $estaOrdenado \gets$ True\;
      }
      $hijo_{0} \gets$ 2x$i$+1\;
      $hijo_{1} \gets$ 2x$i$+2\;
    }
  \end{algoritmo}

  \begin{algoritmo}{iSwap}{\Inout{a}{$\alpha$}, \Inout{b}{$\alpha$}}{}
    \tipo{$\alpha$} $c$\;
    $c \gets a$\;
    $a \gets b$\;
    $b \gets c$\;
  \end{algoritmo}

\end{Algoritmos}
