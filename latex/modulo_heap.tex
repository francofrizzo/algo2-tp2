\section{M\'{o}dulo Heap($\alpha$)}

\begin{Interfaz}
  
  \begin{paramFormales}
    \paramGeneros{$\alpha$}

%    \paramFuncion{
%      \InterfazFuncion{$\bullet = \bullet$}{\In{a_{1}}{$\alpha$}, \In{a_{2}}{$\alpha$}}{bool}
%      {$res \igobs (a_{1} = a_{2})$}
%      [$\Theta(equal(a_{1}, a_{2}))$]
%      [funci\'on de igualdad de $\alpha$]
%    }

    \paramFuncion{
      \InterfazFuncion{$\bullet < \bullet$}{\In{a_{1}}{$\alpha$}, \In{a_{a}}{$\alpha$}}{bool}
      {$res \igobs (a_{1} \leq a_{2})$}
      [$\Theta(compare(a_{1}, a_{2}))$]
      [funci\'{o}n de comparaci\'{o}n de menor de $\alpha$. ] %Teniendo esta y la anterior, las siguientes funciones son triviales ("$\leq$", ">" y "$\geq$")]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
      {$res \igobs a$}
      [$\Theta(copy(a))$]
      [funci\'{o}n de copia de $\alpha$]
    }

  \end{paramFormales}

  \seExplicaCon{colaPrior($\alpha$)}

  \generos{heap($\alpha$)}

  \Encabezado{Operaciones del heap}

    \InterfazFuncion{vac\'{i}o}{}{heap($\alpha$)}
    [true]
    {$res \igobs$ vac\'{i}o}
    [$\Theta(1)$]
    [Constructor por defecto de heap($\alpha$)]

    \InterfazFuncion{encolar}{\Inout{h}{heap($\alpha$)}, \In{a}{$\alpha$}}{}{}
    [$h \igobs h_{0}$]
    {$h \igobs$ encolar($a$, $h_{0}$)}
    [$\Theta(log(h.longitud))$]
    [Agrega un elemento a la cola de prioridades]

    \InterfazFuncion{vac\'{i}o?}{\In{h}{heap($\alpha$)}}{bool}
    [true]
    {$h \igobs$ vac\'{i}o()}
    [$\Theta(1)$]
    [Devuelve true si y solo si h es un heap vac\'{i}o]

    \InterfazFuncion{pr\'{o}ximo}{\In{h}{heap($alpha$)}}{$\alpha$}
    [$\not$(vac\'ia?(h))]    % $\land$ $h_{0} \igobs h$]
    {$res \igobs$ pr\'{o}ximo (h)}
    [$\Theta(1)$]
    [Devuelve el pr\'{o}ximo elemento en el heap]

    \InterfazFuncion{desencolar}{\Inout{h}{heap($alpha$)}}{}
    [$\not$(vac\'ia?(h))]
    {$res \igobs$ desencolar(h)}
    [$\Theta(log(h.longitud))$]
    [Elimina el pr\'{o}ximo elemento en el heap]

    \InterfazFuncion{desencolar2}{\Inout{h}{heap($alpha$)}}{$\alpha$}
    [$h \igobs h_{0} \land \not$(vac\'ia?(h))]
    {$res \igobs$ pr\'{o}ximo($h_{0}$) $\land$ $h$ = desencolar($h_{0}$)}
    [$\Theta(log(h.longitud))$]
    [Elimina el pr\'{o}ximo elemento en el heap]

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{heap($\alpha$)}[vector($\alpha$)]
  \end{Estructura} 

  \Rep[vector($\alpha$)][v]{
    ($\paratodo{i}{nat}$) ((($2 \* i < $long($v$)) $\impluego$ i\'esimo($2 \* i$, $v$) $\leq$ i\'esimo($i$, $v$)) $\land$ (($2 \* i + 1< $long($v$)) $\impluego$ i\'esimo($2 \* i + 1$, $v$) $\leq$ i\'esimo($i$, $v$)))
  
  %1) si A es el padre de B entonces A >= B
  %2) no hay ningun agujero en el vector es decir estan todos cargados consecutivos. por ende el arbol del heap se carga nivel a nivel de izq a der sin dejar ningun nivel con algun nodo sin hijos
  %3) si A es el padre de B entonces (A = hp[i]) entonces ((B=hp[2i+1]) xor (B=hp2i+2)) 
  %4) (es redundante pero creo que agrega mas claridad)
  %    si A es el padre de B entonces (A=hp[i]) entonces (A=hp[((i/2)-((i+1)%2)))])
  }

  \AbsFc[vector($\alpha$)]{colaPrior($\alpha$)}[v]{
    \IF long($v$) = 0 THEN vac\'{i}a() ELSE encolar(prim($v$), Abs(fin($v$))) FI
  }

\end{Representacion}

\begin{Algoritmos}

  \begin{algoritmo}{iVacio}{}{vector($\alpha$)}
    $res \gets Vac\'ia()$ \;
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {La funci\'{o}n Vac\'{i}o() de vector es $\Theta(1)$ por ende Vac\'{i}o() de heap es $\Theta(1)$. } % Justificacíón

  \begin{algoritmo}{iEncolar}{\Inout{hp}{heap($\alpha$)}, \In{a}{$\alpha$}}{}
    $hp$.push\_back($a$)\; \com*{$\Theta(1)$}
    \tipo{nat} $i \gets$ $hp$.longitud - 1\; \com*{$\Theta(1)$}
    \tipo{nat} $p \gets$ (i/2) - ((i+1)\%2)\; \com*{$\Theta(1)$}
    \While{$hp$[$p$] < $hp$[$i$]}{ \com*{$\Theta(log(n))$}
      iSwap($hp$, $p$, $i$)\; \com*{$\Theta(copy(\alpha))$}
      $i \gets p$\; \com*{$\Theta(1)$}
      $p \gets$ ($i$/2) - (($i$+1)\%2)\; \com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(log(n) \times copy(\alpha))$} % Complejidad
  {El while se repite como maximo $log(n)$ veces, donde $n$ es la longitud del vector, y cada iteracion del while tiene complegidad $copy(\alpha)$. } % Justificacíón

  \begin{algoritmo}{iVac\'{i}o?}{\In{v}{vector($\alpha$)}}{bool}
    $res \gets$ esVac\'io?($v$) \; \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{iDesencolar}{\Inout{v}{vector($\alpha$)}}{$\alpha$}
    \tipo{nat} $i \gets$ $v$.longitud - 1\;
    iSwap($v$, $0$, $i$)\; \com*{$\Theta(copy(\alpha))$}
    $res \gets$ $v$.pop\_back()\; \com*{$\Theta(1)$}
    \tipo{nat} $hijo_{0} \gets$ 1\; \com*{$\Theta(1)$}
    \tipo{nat} $hijo_{1} \gets$ 2\; \com*{$\Theta(1)$}
    \tipo{bool} $estaOrdenado \gets$ false\; \com*{$\Theta(1)$}
    \While{$\not$estaOrdenado}{ \com*{$\Theta(log(n))$}
      \eIf{$hijo_{0}$ < $v$.longitud}{
        \eIf{$hijo_{1}$ < $v$.longitud} {
          %//ambos hijos son validos
          \eIf{$v$[$hijo_{0}$] $\geq$ $v$[$hijo_{1}$]}{
            %//hijo0 es mas grande que hijo1
            \eIf{$v$[$hijo_{0}$] > $v$[$i$]}{
              %//hijo0 es mas grande que el padre -> los swapeo
              iSwap($v$, $hijo_{0}$, $i$)\; \com*{$\Theta(copy(\alpha))$}
              $i \gets hijo_{0}$\; \com*{$\Theta(1)$}
            }{
              %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
              $estaOrdenado \gets$ True\; \com*{$\Theta(1)$}
            }
          }{
            %//hijo1 es mas grande que hijo0
            \eIf{$v$[$hijo_{1}$] > $v$[$i$]}{
              %//hijo1 es mas grande que el padre -> los swapeo
              iSwap($v$, $hijo_{1}$, $i$)\; \com*{$\Theta(copy(\alpha))$}
              $i \gets hijo_{1}$\; \com*{$\Theta(1)$}
            }{
              %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
              $estaOrdenado \gets$ True\; \com*{$\Theta(1)$}
            }
          }
        }{
          %//solo hijo0 es valido
          \eIf{$v$[$hijo_{0}$] > $v$[$i$]} {
            %//hijo0 es mas grande que el padre -> los swapeo
            iSwap($v$ ,$hijo_{0}$, $i$)\; \com*{$\Theta(copy(\alpha))$}
            $i \gets hijo_{0}$\; \com*{$\Theta(1)$}
          }{
            %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
            $estaOrdenado \gets$ True\; \com*{$\Theta(1)$}
          }
        }
      }{
        %//ningun hijo es valido por ende no tiene hijos entonces esta ordenado
        $estaOrdenado \gets$ True\; \com*{$\Theta(1)$}
      }
      $hijo_{0} \gets$ 2x$i$+1\; \com*{$\Theta(1)$}
      $hijo_{1} \gets$ 2x$i$+2\; \com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(log(n) \times copy(\alpha))$} % Complejidad
  {El while se repite como m\'{a}ximo $log(n)$ veces, y cada iteracion del while tiene como complegidad $copy(\alpha)$} % Justificacíón

  \begin{algoritmo}{iSwap}{\Inout{v}{vector($\alpha$)}, \In{a}{$nat$}, \In{b}{$nat$}}{}
    \tipo{$\alpha$} $c$\; \com*{$\Theta(1)$}
    $c \gets v$[$a$]\; \com*{$\Theta(copy(\alpha))$}
    $v$[$a$] $\gets v$[$b$]\; \com*{$\Theta(copy(\alpha))$}
    $v$[$a$] $\gets v$[$c$]\; \com*{$\Theta(copy(\alpha))$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(copy(\alpha))$} % Complejidad
  {} % Justificacíón

\end{Algoritmos}
