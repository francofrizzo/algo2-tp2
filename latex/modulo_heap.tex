\section{M\'{o}dulo Heap}

\Encabezado{Notas preliminares}
  En todos los casos, al indicar las complejidades de los algoritmos, las variables que se utilizan corresponden a:
  \vspace{-0.5em}\begin{itemize}
    \item $n$: N\'umero de elementos presentes en la cola de prioridad.
  \end{itemize}

\begin{Interfaz}
  
  \begin{paramFormales}
    \paramGeneros{$\alpha$}

    \paramFuncion{
      \InterfazFuncion{$\bullet \leq \bullet$}{\In{a_{1}}{$\alpha$}, \In{a_{a}}{$\alpha$}}{bool}
      {$res \igobs (a_{1} \leq a_{2})$}
      [$\Theta(compare(a_{1}, a_{2}))$]
      [funci\'on de comparaci\'on por orden total estricto de $\alpha$]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
      {$res \igobs a$}
      [$\Theta(copy(a))$]
      [funci\'{o}n de copia de $\alpha$]
    }

  \end{paramFormales}

  \seExplicaCon{Cola de Prioridad($\alpha$)}

  \generos{\tipo{heap($\alpha$)}}

  \Encabezado{Operaciones de cola de prioridad}

    \InterfazFuncion{vac\'{i}o}{}{heap($\alpha$)}
    [true]
    {$res \igobs$ vac\'{i}o}
    [$\Theta(1)$]
    [Devuelve un heap vac\'io.]

    \InterfazFuncion{encolar}{\Inout{h}{heap($\alpha$)}, \In{a}{$\alpha$}}{}{}
    [$h \igobs h_{0}$]
    {$h \igobs$ encolar($a$, $h_{0}$)}
    [$\Theta(log(n))$]
    [Agrega un elemento al heap.]
    [El elemento se agrega al heap por copia.]

    \InterfazFuncion{vac\'{i}o?}{\In{h}{heap($\alpha$)}}{bool}
    [true]
    {$h \igobs$ vac\'{i}o()}
    [$\Theta(1)$]
    [Devuelve true si y solo si el heap no tiene elementos.]

    \InterfazFuncion{desencolar}{\Inout{h}{heap($alpha$)}}{}
    [$\neg$(vac\'ia?(h))]
    {$res \igobs$ desencolar(h)}
    [$\Theta(log(n))$]
    [Devuelve uno de los elementos de m\'axima prioridad del heap, y lo elimina de la estructura.]
    [El elemento es devuelto por copia.]

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{heap($\alpha$)}[vector($\alpha$)]
  \end{Estructura} 

  \Rep[vector($\alpha$)][v]{
    ($\paratodo{i}{nat}$) ((($2 \* i + 1 < $long($v$)) $\impluego$ i\'esimo($2 \* i + 1$, $v$) $\leq$ i\'esimo($i$, $v$)) $\land$ (($2 \* i + 2 < $long($v$)) $\impluego$ i\'esimo($2 \* i + 2$, $v$) $\leq$ i\'esimo($i$, $v$)))
  }

  \tadOperacion{i\'esimo}{nat/i,secu($\alpha$)/s}{$\alpha$}{$i \leq$ long($\alpha$)}  

  \tadAxioma{i\'esimo($i$, $s$)}{\IF $i = 0$ THEN prim($s$) ELSE i\'esimo($i - 1$, fin($s$)) FI}

  \AbsFc[vector($\alpha$)]{colaPrior($\alpha$)}[v]{
    \IF long($v$) = 0 THEN vac\'{i}a() ELSE encolar(prim($v$), Abs(fin($v$))) FI
  }

\end{Representacion}

\begin{Algoritmos}

  \SetKwFunction{vacia}{Vac\'ia}
  \SetKwFunction{lon}{long}
  \SetKwFunction{swap}{Swap}
  \SetKwFunction{esVacio}{esVac\'io?}

  \begin{algoritmo}{iVac\'io}{}{}
    $res \gets$ \vacia{} \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iEncolar}{\Inout{v}{vector($\alpha$)}, \In{a}{$\alpha$}}{}
    agregarAtras($v$, $a$) \com*{$\Theta(copy(a))$}
    \tipo{nat} $i \gets$ \lon{$v$} \com*{$\Theta(1)$}
    \While{$i \neq 0 \land v[i] < v[i \text{ div } 2 - (i + 1)\%2]$}{
      \swap{$v$, $i$, $i \text{ div } 2 - (i + 1)\%2$} \com*{$\Theta(copy(\alpha))$}
      $i \gets i \text{ div } 2 - (i + 1)\%2$ \com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(log(n)) \times \Theta(copy(\alpha))$} % Complejidad
  {El ciclo se repite como m\'aximo $log(n)$ veces y cada repetici\'on tiene $\Theta(copy(\alpha))$. } % Justificación

  \begin{algoritmo}{iVac\'{i}o?}{\In{v}{vector($\alpha$)}}{bool}
    $res \gets$ \esVacio{$v$} \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iDesencolar}{\Inout{v}{vector($\alpha$)}}{$\alpha$}
    $res \gets$ \copiar{$v[0]$} \com*{$\Theta(copy(v[0]))$}
    \tipo{nat} $i \gets 0$ \com*{$\Theta(1)$}
    \While{(($2i + 1 \leq$ \lon{$v$}) $\land$ $v[i] < v[2i + 1]$) $\lor$ ($2i + 2 \leq$ \lon{$v$}) $\land$ $v[i] < v[2i + 2]$)}{
      \eIf{$2i + 2 \leq$ \lon{$v$}}{
        \eIf{$v[i] < v[2i + 2]$}{
          \swap{$v$, $i$, $2i + 2$} \com*{$\Theta(copy(\alpha))$}
          $i \gets 2i + 2$ \com*{$\Theta(1)$}
        }{
          \swap{$v$, $i$, $2i + 1$} \com*{$\Theta(copy(\alpha))$}
          $i \gets 2i + 1$ \com*{$\Theta(1)$}
        }
      }{
        \swap{$v$, $i$, $2i + 1$} \com*{$\Theta(copy(\alpha))$}
        $i \gets 2i + 1$ \com*{$\Theta(1)$}
      }
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(log(n)) \times \Theta(copy(\alpha))$} % Complejidad
  {El ciclo se repite como m\'aximo $log(n)$ veces y cada repetici\'on tiene $\Theta(copy(\alpha))$. } % Justificación

  \begin{algoritmo}{iSwap}{\Inout{v}{vector($\alpha$)}, \In{i}{nat}, \In{j}{nat}}{}
    \tipo{$\alpha$} $aux \gets v[i]$ \com*{$\Theta(copy(\alpha))$}
    $v[i] \gets v[j]$ \com*{$\Theta(copy(\alpha))$}
    $v[j] \gets aux$ \com*{$\Theta(copy(\alpha))$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {$i < \,$ long($v$) $\land$ $j < \,$ long($v$)} % Pre
  {} % Post
  {$\Theta(copy(\alpha))$} % Complejidad
  {$3 \times \Theta(copy(\alpha)) = \Theta(copy(\alpha))$} % Justificación

\end{Algoritmos}
