\section{M\'{o}dulo Heap($\alpha$)}

\begin{Interfaz}
  
  \begin{paramFormales}
    \paramGeneros{$\alpha$}

    \paramFuncion{
      \InterfazFuncion{$\bullet \leq \bullet$}{\In{a_{1}}{$\alpha$}, \In{a_{a}}{$\alpha$}}{bool}
      {$res \igobs (a_{1} \leq a_{2})$}
      [$\Theta(compare(a_{1}, a_{2}))$]
      [funci\'on de comparaci\'on por orden total estricto de $\alpha$] %Teniendo esta y la anterior, las siguientes funciones son triviales ("$\leq$", ">" y "$\geq$")]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
      {$res \igobs a$}
      [$\Theta(copy(a))$]
      [funci\'{o}n de copia de $\alpha$]
    }

  \end{paramFormales}

  \seExplicaCon{Cola de Prioridad($\alpha$)}

  \generos{\tipo{heap($\alpha$)}}

  \Encabezado{Operaciones de cola de prioridad}

    \InterfazFuncion{vac\'{i}o}{}{heap($\alpha$)}
    [true]
    {$res \igobs$ vac\'{i}o}
    [$\Theta(1)$]
    [Devuelve un heap vac\'io.]

    \InterfazFuncion{encolar}{\Inout{h}{heap($\alpha$)}, \In{a}{$\alpha$}}{}{}
    [$h \igobs h_{0}$]
    {$h \igobs$ encolar($a$, $h_{0}$)}
    [$\Theta(log(n))$]
    [Agrega un elemento al heap.]

    \InterfazFuncion{vac\'{i}o?}{\In{h}{heap($\alpha$)}}{bool}
    [true]
    {$h \igobs$ vac\'{i}o()}
    [$\Theta(1)$]
    [Devuelve true si y solo si el heap no tiene elementos.]

    \InterfazFuncion{desencolar}{\Inout{h}{heap($alpha$)}}{}
    [$\not$(vac\'ia?(h))]
    {$res \igobs$ desencolar(h)}
    [$\Theta(log(n))$]
    [Devuelve uno de los elementos de m\'axima prioridad del heap, y lo elimina de la estructura.]

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{heap($\alpha$)}[vector($\alpha$)]
  \end{Estructura} 

  \Rep[vector($\alpha$)][v]{
  \AbsFc[vector($\alpha$)]{colaPrior($\alpha$)}[h]{
    \IF h.long = 0 THEN vac\'{i}a() ELSE encolar(prim(h), ABS(fin(h))) FI
  }

\end{Representacion}

\begin{Algoritmos}

  \begin{algoritmo}{iVac\'{i}o}{}{heap($\alpha$)}
    $res \gets$ vector<$\alpha$>\;
  \end{algoritmo}

  \begin{algoritmo}{iEncolar}{\Inout{hp}{heap($\alpha$)}, \In{a}{$\alpha$}}{}
    $hp$.push\_back($a$)\;
    \tipo{nat} $i \gets$ $hp$.longitud - 1\;
    \tipo{nat} $p \gets$ (i/2) - ((i+1)\%2)\;
    \While{$hp$[$p$] < $hp$[$i$]}{
      iSwap($hp$[$p$], $hp$[$i$])\;
      $i \gets p$\;
      $p \gets$ ($i$/2) - (($i$+1)\%2)\;
    }
  \end{algoritmo}

  \begin{algoritmo}{iVac\'{i}o?}{\In{hp}{heap($\alpha$)}}{bool}
    $res \gets$ ($hp$ = vac\'{i}o())\;
  \end{algoritmo}

  \begin{algoritmo}{iProximo}{\In{hp}{heap($\alpha$)}}{$\alpha$}
    $res \gets$ hp[0]\;
  \end{algoritmo}

  \begin{algoritmo}{iDesencolar}{\Inout{hp}{heap($\alpha$)}}{$\alpha$}

    \tipo{nat} $i \gets$ $hp$.longitud - 1\;
    iSwap($hp$[$0$], $hp$[$i$])\;
    $res \gets$ $hp$.pop\_back()\;

    \tipo{nat} $hijo_{0} \gets$ 1\;
    \tipo{nat} $hijo_{1} \gets$ 2\;
    \tipo{bool} $estaOrdenado \gets$ false\;

    \While{$\not$estaOrdenado}{
      \eIf{$hijo_{0}$ < $hp$.longitud}{
        \eIf{$hijo_{1}$ < $hp$.longitud} {
          %//ambos hijos son validos
          \eIf{$hp$[$hijo_{0}$] $\geq$ $hp$[$hijo_{1}$]}{
            %//hijo0 es mas grande que hijo1
            \eIf{$hp$[$hijo_{0}$] > $hp$[$i$]}{
              %//hijo0 es mas grande que el padre -> los swapeo
              iSwap($hp$[$hijo_{0}$], $hp$[$i$])\;
              $i \gets hijo_{0}$\;
            }{
              %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
              $estaOrdenado \gets$ True\;
            }
          }{
            %//hijo1 es mas grande que hijo0
            \eIf{$hp$[$hijo_{1}$] > $hp$[$i$]}{
              %//hijo1 es mas grande que el padre -> los swapeo
              iSwap($hp$[$hijo_{1}$], $hp$[$i$])\;
              $i \gets hijo_{1}$\;
            }{
              %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
              $estaOrdenado \gets$ True\;
            }
          }
        }{
          %//solo hijo0 es valido
          \eIf{$hp$[$hijo_{0}$] > $hp$[$i$]} {
            %//hijo0 es mas grande que el padre -> los swapeo
            iSwap($hp$[$hijo_{0}$], $hp$[$i$])\;
            $i \gets hijo_{0}$\;
          }{
            %//el hijo mas grande es menor a el padre...ESTA ORDENADO!
            $estaOrdenado \gets$ True\;
          }
        }
      }{
        %//ningun hijo es valido por ende no tiene hijos entonces esta ordenado
        $estaOrdenado \gets$ True\;
      }
      $hijo_{0} \gets$ 2x$i$+1\;
      $hijo_{1} \gets$ 2x$i$+2\;
    }
  \end{algoritmo}

  \begin{algoritmo}{iSwap}{\Inout{a}{$\alpha$}, \Inout{b}{$\alpha$}}{}
    \tipo{$\alpha$} $c$\;
    $c \gets a$\;
    $a \gets b$\;
    $b \gets c$\;
  \end{algoritmo}

\end{Algoritmos}
