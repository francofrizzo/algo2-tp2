\section{M\'{o}dulo Heap}

\Encabezado{Notas preliminares}
  En todos los casos, al indicar las complejidades de los algoritmos, las variables que se utilizan corresponden a:
  \vspace{-0.5em}\begin{itemize}
    \item $n$: N\'umero de elementos presentes en la cola de prioridad.
  \end{itemize}

\begin{Interfaz}
  
  \begin{paramFormales}
    \paramGeneros{$\alpha$}

    \paramFuncion{
      \InterfazFuncion{$\bullet \leq \bullet$}{\In{a_{1}}{$\alpha$}, \In{a_{a}}{$\alpha$}}{bool}
      {$res \igobs (a_{1} \leq a_{2})$}
      [$\Theta(compare(a_{1}, a_{2}))$]
      [funci\'on de comparaci\'on por orden total estricto de $\alpha$]
    }

    \paramFuncion{
      \InterfazFuncion{Copiar}{\In{a}{$\alpha$}}{$\alpha$}
      {$res \igobs a$}
      [$\Theta(copy(a))$]
      [funci\'{o}n de copia de $\alpha$]
    }

  \end{paramFormales}

  \seExplicaCon{Cola de Prioridad($\alpha$)}

  \generos{\tipo{heap($\alpha$)}}

  \Encabezado{Operaciones de cola de prioridad}

    \InterfazFuncion{vac\'{i}o}{}{heap($\alpha$)}
    [true]
    {$res \igobs$ vac\'{i}o}
    [$\Theta(1)$]
    [Devuelve un heap vac\'io.]

    \InterfazFuncion{encolar}{\Inout{h}{heap($\alpha$)}, \In{a}{$\alpha$}}{}{}
    [$h \igobs h_{0}$]
    {$h \igobs$ encolar($a$, $h_{0}$)}
    [$\Theta(log(n))$]
    [Agrega un elemento al heap.]

    \InterfazFuncion{vac\'{i}o?}{\In{h}{heap($\alpha$)}}{bool}
    [true]
    {$h \igobs$ vac\'{i}o()}
    [$\Theta(1)$]
    [Devuelve true si y solo si el heap no tiene elementos.]

    \InterfazFuncion{desencolar}{\Inout{h}{heap($alpha$)}}{}
    [$\neg$(vac\'ia?(h))]
    {$res \igobs$ desencolar(h)}
    [$\Theta(log(n))$]
    [Devuelve uno de los elementos de m\'axima prioridad del heap, y lo elimina de la estructura.]

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{heap($\alpha$)}[vector($\alpha$)]
  \end{Estructura} 

  \Rep[vector($\alpha$)][v]{
    ($\paratodo{i}{nat}$) ((($2 \* i < $long($v$)) $\impluego$ i\'esimo($2 \* i$, $v$) $\leq$ i\'esimo($i$, $v$)) $\land$ (($2 \* i + 1< $long($v$)) $\impluego$ i\'esimo($2 \* i + 1$, $v$) $\leq$ i\'esimo($i$, $v$)))
  }

  \tadOperacion{i\'esimo}{nat/i,secu($\alpha$)/s}{$\alpha$}{$i \leq$ long($\alpha$)}  

  \tadAxioma{i\'esimo($i$, $s$)}{\IF $i = 0$ THEN prim($s$) ELSE i\'esimo($i - 1$, fin($s$)) FI}

  \AbsFc[vector($\alpha$)]{colaPrior($\alpha$)}[v]{
    \IF long($v$) = 0 THEN vac\'{i}a() ELSE encolar(prim($v$), Abs(fin($v$))) FI
  }

\end{Representacion}

\begin{Algoritmos}

  \begin{algoritmo}{iVacio}{}{vector($\alpha$)}
    $res \gets Vac\'ia()$ \;
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iEncolar}{\Inout{v}{vector($\alpha$)}, \In{a}{$\alpha$}}{}
    agregarAtras($v$, $a$) \;
    \tipo{nat} $i \gets $long$(v)$ \;
    \While{$i \neq 0 \land v[i] < v[i \text{ div } 2 - (i + 1)\%2]$}{
      swap($v$, $i$, $i \text{ div } 2 - (i + 1)\%2$) \;
      $i \gets i \text{ div } 2 - (i + 1)\%2$ \;
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iVac\'{i}o?}{\In{v}{vector($\alpha$)}}{bool}
    $res \gets$ esVac\'io?($v$) \;
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iDesencolar}{\Inout{v}{vector($\alpha$)}}{$\alpha$}
    $res \gets v[0]$ \;
    \tipo{nat} $i \gets 0$ \;
    \While{(($2i + 1 \leq$ long($v$)) $\land$ $v[i] < v[2i + 1]$) $\lor$ ($2i + 2 \leq$ long($v$)) $\land$ $v[i] < v[2i + 2]$)}{
      \eIf{$2i + 2 \leq$ long($v$)}{
        \eIf{$v[i] < v[2i + 2]$}{
          swap($v$, $i$, $2i + 2$) \;
          $i \gets 2i + 2$ \;
        }{
          swap($v$, $i$, $2i + 1$) \;
          $i \gets 2i + 1$ \;
        }
      }{
        swap($v$, $i$, $2i + 1$) \;
        $i \gets 2i + 1$ \;
      }
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificación

  \begin{algoritmo}{iSwap}{\Inout{v}{vector($\alpha$)}, \In{i}{nat}, \In{j}{nat}}{}
    \tipo{$\alpha$} $aux \gets v[i]$ \;
    $v[i] \gets v[j]$ \;
    $v[j] \gets aux$ \;
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificación

\end{Algoritmos}
