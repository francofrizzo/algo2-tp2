\section{M\'{o}dulo Red}

\begin{Interfaz}
  
  \seExplicaCon{Red, Iterador Bidireccional(Compu)}

  \generos{\tipo{red}, \tipo{itRed}}
  
  \Titulo{Operaciones b\'{a}sicas de red}

  \InterfazFuncion{iniciarRed}{}{Red}%
  {res $\igobs$ iniciarRed()}%pos
  [$\Theta(1234)$]%complejidad
  [Genera una nueva red sin ninguna computadora.]%descripcion
  []%aliasing
  
  \InterfazFuncion{agregarCompu}{\Inout{R}{Red}, \In{c}{compu}}{}%
  [$R$ $\igobs$ $R_{0}$ $\land$ ($\forall c'$: compu)($c' \in$ computadoras($r$) $\rightarrow$ ip($c$) $\neq$ ip($c'$))]%pre
  {$R$ $\igobs$ agregarCompu($R_{0}$, c)}%pos
  [$\Theta(1324)$]%complejidad
  [Agrega una nueva pc a una red.]%descripcion
  []%aliasing

  \InterfazFuncion{conectar}{\Inout{r}{Red}, \In{c_0}{compu}, \In{i_0}{interfaz}, \In{c_1}{compu}, \In{i_1}{interfaz}}{red}%
  [$R$ $\igobs$ $R_{0}$ $\land c_{1} \in $computadoras($r$) $\land c_{2} \in$ computadoras($r$) $\land$ ip($c_{0} $) $\neq$ ip($c_{1} $) $\land \not$conectadas?($r$, $c_{0}$ ,$c_{1} $) $\land \not$ usaInterfaz?($r$, $c_{0}$, $i_{0}$) $\land \not$ usaInterfaz?($r$, $c_{1}$, $i_{1}$)]%pre
  {$R$ $\igobs$ conectar($R_{0}$, $c_{0}$, $i_{0}$, $c_{1}$, $i_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Conecta la pc $c_{0}$ con la pc $c_{1}$ a trav\'es de las interfaces $i_{0}$ y $i_{1}$ respectivamente. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{computadoras}{\In{R}{Red}}{conj(compus)}%
  {$res$ $\igobs$ computadoras(R) } %es alias(res,compus(R))             %pos
  [$\Theta(1234)$]%complejidad
  [Devuelve todas las computadoras de la red. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{conectadas?}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{bool}%
  [$c_{0}$ $\in$ computadoras($R$) $\land c_{1} \in $ computadoras($R$)]%pre
  {$res$ $\igobs$ conectadas?($R$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve true si y solo si la pc $c_{0}$ esta conectada a la pc $c_{1}$]%descripcion
  []%aliasing
  
  \InterfazFuncion{interfazUsada}{\In{R}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{interfaz}%
  [$c_{0}$ $\in$ computadoras($R$) $\land c_{1} \in $ computadoras($R$) $\yluego$ conectadas?($R$, $c_{0}$, $c_{1}$)]%pre
  {$res$ $\igobs$ interfazUsada($R$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve la interfaz usada por $c_{0}$ para conectarse a $c_{1}$]%descripcion
  []%aliasing
  
  \InterfazFuncion{vecinos}{\In{R}{Red}, \In{c}{compu}}{conj(compus)}%
  [$c$ $\in$ computadoras($R$)]%pre
  {$res$ $\igobs$ vecinos($R$, $c$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve el conjunto de vecinos de la pc $c$]%descripcion
  []%aliasing
  
  \InterfazFuncion{usaInterfaz?}{\In{R}{Red}, \In{c}{compu}, \In{i}{interfaz}{bool}}%
  [$c$ $\in$ computadoras($R$)]%pre
  {$res$ $\igobs$ usaInterfaz?($R$, $c$, $i$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve true si y solo si la pc $c$ esta usando la interfaz $i$. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{caminosMinimos}{\In{R}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{conj(secu(compus))}%
  [$c_{0}$ $\in$ computadoras($R$) $\land c_{1} \in $ computadoras($R$)]%pre
  {$res$ $\igobs$ caminosMinimos($R$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve todos los caminos m\'nimos posibles entre $c_{0}$ y $c_{1}$. De no haber ninguno, devuelve $\emptyset$. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{hayCamino?}{\In{R}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{bool}%
  [$c_{0}$ $\in$ computadoras($R$) $\land c_{1} \in $ computadoras($R$)]%pre
  {$res$ $\igobs$ hayCamino?($R$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve true si y solo si hay alg\'un camino posible entre $c_{0}$ y $c_{1}$. ]%descripcion
  []%aliasing

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{red}[estrRed]

    \begin{Tupla}[estrRed]
      \tupItem{compus}{lista(estrCompu)}
      \tupItem{cantidadCompus}{nat}
    \end{Tupla}

    \begin{Tupla}[estrCompu]
      \tupItem{IP}{string}
      \tupItem{conexiones}{lista(tupla(interfaz, itLista(estrCompu)))}
    \end{Tupla}

  \end{Estructura}

  \begin{Estructura}{itRed}[itLista(estrCompu)]
  \end{Estructura}

  \RepFc[Red][e]{($\forall c$: compu)(c $\in$ ArmarComputadoras(e.conexiones) $\impluego$ $\lnot$ Pertenece?(e.conexiones, c, c))$\land$ \\
    $\#$ArmarComputadoras(e.conexiones) = e.cantidadCompus $\land$ \\
    ($\forall c_{1}$: compu)(($\forall c_{2}$: compu) ($c_{1}$ $\in$ ArmarComputadoras(e.conexiones) $\land$ $c_{2}$ $\in$ ArmarComputadoras(e.conexiones) $\impluego$ Pertenece?(e.conexiones, $c_{1}$, $c_{2}$) $\Leftrightarrow$ Pertenece?(e.conexiones, $c_{2}$, $c_{1}$))) $\land$ \\
    ($\forall c_{1}$: compu)($c_{1}$ $\in$ ArmarComputadoras(e.conexiones) $\impluego$ ($\forall c_{2}$: compu) (Pertenece?(e.conexiones, $c_{1}$, $c_{2}$) $\Rightarrow$ $c_{2}$ $\in$ ArmarComputadoras(e.conexiones))) $\land$ \\
    sinRepetidos(ArmarSecuencia(e.conexiones)) 
    %FALTAN SINREPETIDOS Y ARMAR SECUENCIA
    }\mbox{}

  ~

  \AbsFc[estrRed]{Red}[e]{(r: Red | computadoras(r) = ArmarComputadoras(e.conexiones) $\land$ \\
    ($\forall c_{1}$: compu)(($\forall c_{2}$: compu) conectados?(r, $c_{1}$, $c_{2}$) = Pertenece?(e.conexiones, $c_{1}$, $c_{2}$) $\land$ \\
    InterfazUsada(r, $c_{1}$, $c_{2}$) = DevolverInterfaz(e.conexiones, $c_{1}$, $c_{2}$)))
  }

  ~      

  \tadOperacion{ArmarComputadoras}{lista(tupla<string, lista(tupla<Interfaz, ItRed>)>)}{conj(compu)}{} %falta arreglar comas
  \tadAxioma{ArmarComputadoras($l$)}{\IF vacia?(l) THEN $\emptyset$ ELSE Ag(<$\pi_{1}$(prim($l$)), GenerarInterfaces($\pi_{2}$(prim($l$)))>, ArmarComputadoras(fin($l$))) FI}

  ~

  \tadOperacion{GenerarInterfaces}{lista(tupla<Interfaz, ItLista(estrCompu)>)}{conj(Interfaz)}{}
  \tadAxioma{GenerarInterfaces($l$)}{\IF vacia?($l$) THEN $\emptyset$ ELSE Ag($\pi_{1}$(prim($l$)), GenerarInterfaces(fin($l$))) FI}

  ~

  \tadOperacion{Pertenece?}{lista(tupla<string, lista(tupla<Interfaz, ItRed>)>)/l, compu/c_{1}, compu/c_{2}}{bool}{}
  \tadAxioma{Pertenece?($l$, $c_{1}$, $c_{2}$)}{\IF ($\pi_{1}$(prim($l$) = $\pi_{1}$($c_{1}$))) THEN $\pi_{1}$($c_{2}$) $\in$ GenerarCompus($\pi_{2}$(prim($l$))) ELSE Pertenece?(fin($l$), $c_{1}$, $c_{2}$) FI}

  ~

  \tadOperacion{GenerarCompus}{lista(tupla<Interfaz, ItLista(estrCompu)>)}{conj(string)}{}
  \tadAxioma{GenerarCompus($l$)}{\IF vacia?($l$) THEN $\emptyset$ ELSE Ag($\pi_{1}$(siguiente($\pi_{2}$(prim($l$)))), GenerarCompus(fin($l$))) FI}

  ~

  \tadOperacion{DevolverInterfaz}{lista(tupla<string, lista(tupla<Interfaz, ItRed>)>)/l, compu/c_{1}, compu/c_{2}}{Interfaz}{} % Restriccion? Pertenece?(l, c1, c2) o c1 \in computadoras(r)
  \tadAxioma{DevolverInterfaz($l$, $c_{1}$, $c_{2}$)}{\IF ($\pi_{1}$(prim($l$)) = $\pi_{1}$($c_{1}$)) THEN DevolverInterfazAux($\pi_{2}$(prim($l$), $c_{2}$)) ELSE DevolverInterfaz(fin($l$, $c_{1}$, $c_{2}$)) FI}

  ~  
  
   \tadOperacion{DevolverInterfazAux}{lista(tupla<Interfaz, ItRed>)/l, compu/c}{Interfaz}{} % Restriccion? Pertenece?(l, c1, c2) o c1 \in computadoras(r)
  \tadAxioma{DevolverInterfaz($l$, $c$)}{\IF ($\pi_{1}$($c_{2}$) = $\pi_{1}$(siguiente($\pi_{2}$(prim($l$))))) THEN $\pi_{1}$(prim($l$)) ELSE DevolverInterfazAux(fin($l$, c)) FI}

  ~

\end{Representacion}
