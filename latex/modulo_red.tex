\section{M\'{o}dulo Red}

\begin{Interfaz}
  
  \seExplicaCon{Red, Iterador Unidireccional(Compu)}

  \generos{\tipo{red}, \tipo{itRed}}
  
  \Encabezado{Operaciones b\'{a}sicas de red}

  \InterfazFuncion{iniciarRed}{}{Red}%
  {res $\igobs$ iniciarRed()}%pos
  [$\Theta(1234)$]%complejidad
  [Genera una nueva red sin ninguna computadora.]%descripcion
  []%aliasing
  
  \InterfazFuncion{agregarCompu}{\Inout{r}{Red}, \In{c}{compu}}{}%
  [$r$ $\igobs$ $r_{0}$ $\land$ ($\forall c'$: compu)($c' \in$ computadoras($r$) $\rightarrow$ ip($c$) $\neq$ ip($c'$))]%pre
  {$r$ $\igobs$ agregarCompu($r_{0}$, c)}%pos
  [$\Theta(1324)$]%complejidad
  [Agrega una nueva pc a una red.]%descripcion
  []%aliasing

  \InterfazFuncion{conectar}{\Inout{r}{Red}, \In{c_0}{compu}, \In{i_0}{interfaz}, \In{c_1}{compu}, \In{i_1}{interfaz}}{Red}%
  [$r$ $\igobs$ $r_{0}$ $\land$ $c_{1} \in$ computadoras($r$) $\land$ $c_{2} \in$ computadoras($r$) $\land$ ip($c_{0} $) $\neq$ ip($c_{1}$) $\land$ $\lnot$conectadas?($r$, $c_{0}$ , $c_{1} $) $\land$ $\lnot$usaInterfaz?($r$, $c_{0}$, $i_{0}$) $\land$ $\lnot$usaInterfaz?($r$, $c_{1}$, $i_{1}$)]%pre
  {$r$ $\igobs$ conectar($r_{0}$, $c_{0}$, $i_{0}$, $c_{1}$, $i_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Conecta la pc $c_{0}$ con la pc $c_{1}$ a trav\'es de las interfaces $i_{0}$ y $i_{1}$ respectivamente. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{computadoras}{\In{r}{Red}}{conj(compu)}%
  {$res$ $\igobs$ computadoras(r)} %es alias(res,compus(R))             %pos
  [$\Theta(1234)$]%complejidad
  [Devuelve todas las computadoras de la red. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{conectadas?}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{bool}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)]%pre
  {$res$ $\igobs$ conectadas?($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve true si y solo si la pc $c_{0}$ esta conectada a la pc $c_{1}$]%descripcion
  []%aliasing
  
  \InterfazFuncion{interfazUsada}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{interfaz}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$) $\yluego$ conectadas?($r$, $c_{0}$, $c_{1}$)]%pre
  {$res$ $\igobs$ interfazUsada($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve la interfaz usada por $c_{0}$ para conectarse a $c_{1}$]%descripcion
  []%aliasing
  
  \InterfazFuncion{vecinos}{\In{r}{Red}, \In{c}{compu}}{conj(compu)}%
  [$c$ $\in$ computadoras($r$)]%pre
  {$res$ $\igobs$ vecinos($r$, $c$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve el conjunto de vecinos de la pc $c$]%descripcion
  []%aliasing
  
  \InterfazFuncion{usaInterfaz?}{\In{r}{Red}, \In{c}{compu}, \In{i}{interfaz}}{bool}%
  [$c$ $\in$ computadoras($r$)]%pre
  {$res$ $\igobs$ usaInterfaz?($r$, $c$, $i$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve true si y solo si la pc $c$ esta usando la interfaz $i$. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{caminosMinimos}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{conj(secu(compu))}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)]%pre
  {$res$ $\igobs$ caminosMinimos($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve todos los caminos m\'nimos posibles entre $c_{0}$ y $c_{1}$. De no haber ninguno, devuelve $\emptyset$. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{hayCamino?}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{bool}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)]%pre
  {$res$ $\igobs$ hayCamino?($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve true si y solo si hay alg\'un camino posible entre $c_{0}$ y $c_{1}$. ]%descripcion
  []%aliasing

  \Encabezado{Operaciones b\'{a}sicas del iterador de red}

  \InterfazFuncion{crearIt}{\In{r}{Red}}{itRed}%
  [true]%pre
  {$res$ $\igobs$ crearItUni($r$.compus)}%pos
  [$\Theta(1)$]%complejidad
  [??????????. ]%descripcion
  [Crea un iterador de red. ]%aliasing

  \InterfazFuncion{haySiguiente?}{\In{it}{itRed}}{bool}%
  [true]%pre
  {$res$ $\igobs$ hayMas?($it$)}%pos
  [$\Theta(1)$]%complejidad
  [Devuelve true si y solo si $it$ tiene siguiente. ]%descripcion
  []%aliasing

  \InterfazFuncion{siguiente}{\In{it}{itRed}}{compu}%
  [true]%pre
  {$res$ $\igobs$ actual($it$)}%pos
  [$\Theta(1)$]%complejidad
  [??????????. ]%descripcion
  [$res$ se devuelve por referencia]%aliasing

  \InterfazFuncion{avanzar}{\Inout{it}{itRed}}{}%
  [$it \igobs$ $it_{0}$ $\land$ haySiguiente?($it$)]%pre
  {$it$ $\igobs$ avanzar($it_{0}$)}%pos
  [$\Theta(1)$]%complejidad
  [Avanza el iterador a la siguiente posicion. ]%descripcion
  []%aliasing

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{Red}[estrRed]

    \begin{Tupla}[estrRed]
      \tupItem{compus}{lista(estrCompu)}
      \tupItem{cantidadCompus}{nat}
    \end{Tupla}

    \begin{Tupla}[estrCompu]
      \tupItem{IP}{string}
      \tupItem{conexiones}{lista(tupla(interfaz, itLista(estrCompu)))}
    \end{Tupla}

  \end{Estructura}

  \begin{Estructura}{itRed}[itLista(estrCompu)]
  \end{Estructura}

  \RepFc[Red][e]{($\forall c$: compu)(c $\in$ ArmarComputadoras(e.conexiones) $\impluego$ $\lnot$ Pertenece?(e.conexiones, c, c))$\land$ \\
    $\#$ArmarComputadoras(e.conexiones) = e.cantidadCompus $\land$ \\
    ($\forall c_{1}$: compu)(($\forall c_{2}$: compu) ($c_{1}$ $\in$ ArmarComputadoras(e.conexiones) $\land$ $c_{2}$ $\in$ ArmarComputadoras(e.conexiones) $\impluego$ Pertenece?(e.conexiones, $c_{1}$, $c_{2}$) $\Leftrightarrow$ Pertenece?(e.conexiones, $c_{2}$, $c_{1}$))) $\land$ \\
    ($\forall c_{1}$: compu)($c_{1}$ $\in$ ArmarComputadoras(e.conexiones) $\impluego$ ($\forall c_{2}$: compu) (Pertenece?(e.conexiones, $c_{1}$, $c_{2}$) $\Rightarrow$ $c_{2}$ $\in$ ArmarComputadoras(e.conexiones))) $\land$ \\
    sinRepetidos(ArmarSecuencia(e.conexiones)) 
    %FALTAN SINREPETIDOS Y ARMAR SECUENCIA
    }\mbox{}

  ~

  \AbsFc[estrRed]{Red}[e]{(r: Red | computadoras(r) = ArmarComputadoras(e.conexiones) $\land$ \\
    ($\forall c_{1}$: compu)(($\forall c_{2}$: compu) conectados?(r, $c_{1}$, $c_{2}$) = Pertenece?(e.conexiones, $c_{1}$, $c_{2}$) $\land$ \\
    InterfazUsada(r, $c_{1}$, $c_{2}$) = DevolverInterfaz(e.conexiones, $c_{1}$, $c_{2}$)))
  }

  \RepFc[itRed][it]{true}\mbox{}

  ~

  \AbsFc[itRed]{itUni(estrCompu)}[itl]{
    $itr$: itUni(estrCompu)| siguientes($itr$) $\igobs$ armarCompus(siguiente($itl$))
  }

  ~

  \tadOperacion{ArmarComputadoras}{lista(tupla<string, lista(tupla<Interfaz, ItRed>)>)}{conj(compu)}{} %falta arreglar comas
  \tadAxioma{ArmarComputadoras($l$)}{\IF vacia?(l) THEN $\emptyset$ ELSE Ag(<$\pi_{1}$(prim($l$)), GenerarInterfaces($\pi_{2}$(prim($l$)))>, ArmarComputadoras(fin($l$))) FI}

  ~

  \tadOperacion{GenerarInterfaces}{lista(tupla<Interfaz, ItLista(estrCompu)>)}{conj(Interfaz)}{}
  \tadAxioma{GenerarInterfaces($l$)}{\IF vacia?($l$) THEN $\emptyset$ ELSE Ag($\pi_{1}$(prim($l$)), GenerarInterfaces(fin($l$))) FI}

  ~

  \tadOperacion{Pertenece?}{lista(tupla<string, lista(tupla<Interfaz, ItRed>)>)/l, compu/c_{1}, compu/c_{2}}{bool}{}
  \tadAxioma{Pertenece?($l$, $c_{1}$, $c_{2}$)}{\IF ($\pi_{1}$(prim($l$) = $\pi_{1}$($c_{1}$))) THEN $\pi_{1}$($c_{2}$) $\in$ GenerarCompus($\pi_{2}$(prim($l$))) ELSE Pertenece?(fin($l$), $c_{1}$, $c_{2}$) FI}

  ~

  \tadOperacion{GenerarCompus}{lista(tupla<Interfaz, ItLista(estrCompu)>)}{conj(string)}{}
  \tadAxioma{GenerarCompus($l$)}{\IF vacia?($l$) THEN $\emptyset$ ELSE Ag($\pi_{1}$(siguiente($\pi_{2}$(prim($l$)))), GenerarCompus(fin($l$))) FI}

  ~

  \tadOperacion{DevolverInterfaz}{lista(tupla<string, lista(tupla<Interfaz, ItRed>)>)/l, compu/c_{1}, compu/c_{2}}{Interfaz}{} % Restriccion? Pertenece?(l, c1, c2) o c1 \in computadoras(r)
  \tadAxioma{DevolverInterfaz($l$, $c_{1}$, $c_{2}$)}{\IF ($\pi_{1}$(prim($l$)) = $\pi_{1}$($c_{1}$)) THEN DevolverInterfazAux($\pi_{2}$(prim($l$), $c_{2}$)) ELSE DevolverInterfaz(fin($l$, $c_{1}$, $c_{2}$)) FI}

  ~  
  
   \tadOperacion{DevolverInterfazAux}{lista(tupla<Interfaz, ItRed>)/l, compu/c}{Interfaz}{} % Restriccion? Pertenece?(l, c1, c2) o c1 \in computadoras(r)
  \tadAxioma{DevolverInterfaz($l$, $c$)}{\IF ($\pi_{1}$($c_{2}$) = $\pi_{1}$(siguiente($\pi_{2}$(prim($l$))))) THEN $\pi_{1}$(prim($l$)) ELSE DevolverInterfazAux(fin($l$, c)) FI}

  ~

  \tadOperacion{armarCompus}{lista(estrCompu)/l}{secu(compu)}{}
  \tadAxioma{armarCompus($es$)}{\IF vac\'{i}a(es) THEN <> ELSE armarCompu(prim($es$)) $\bullet$ armarCompus(fin($es$)) FI}

  ~

  \tadOperacion{armarCompu}{estrCompu/e}{compu}{}
  \tadAxioma{armarCompus($e$)}{$\langle e$.IP, dame$\Pi_{1}$($e$.conecciones)$\rangle$}

  ~

  \tadOperacion{dame$\Pi_{1}$}{secu(tupla$\langle inter$: interfaz, $itCompu$: itLista(estrCompu)$\rangle$)/l}{conj(interfaz)}{}
  \tadAxioma{dame$\Pi_{1}$($l$)}{\IF vac\'{i}a($l$) THEN $\emptyset$ ELSE ag($Pi_{1}$(prim($l$)), dame$\Pi_{1}$(fin($l$)))FI}

  ~

\end{Representacion}

\begin{Algoritmos}

  \begin{Estructura}{red}[estrRed]

    \begin{Tupla}[estrRed]
      \tupItem{compus}{lista(estrCompu)}
      \tupItem{cantidadCompus}{nat}
    \end{Tupla}

    \begin{Tupla}[estrCompu]
      \tupItem{IP}{string}
      \tupItem{conexiones}{lista(tupla($inter$: interfaz, $itCompu$: itLista(estrCompu)))} %un it a la lista de las interfaces, asi llego al ip. idem para conexiones... siguiente($Pi_{2}$(siguiente($it_{x}$))).IP O siguiente(siguiente($it_{x}$).itCompu).IP
    \end{Tupla}

  \end{Estructura}


  \begin{algoritmo}{iVacia}{}{estrRed}{
    $res \gets \langle$<>, 0$\rangle$ \com*{$\Theta(1)$}
  }
  \end{algoritmo}

  \begin{algoritmo}{iAgregarCompu}{\Inout{r}{estrRed}, \In{c}{estrCompu}}{}
    agregarAtras(r.compus, $\langle$c.IP, iArmarLista(c.interfaces)$\rangle$)\;
    $r.cantidadCompus \gets r.cantidadCompus+1$ \com*{$\Theta(1)$}
  \end{algoritmo}

  \begin{algoritmo}{iArmarLista}{\In{ci}{conj(interfaz)}}{lista($\langle$Interfaz, itLista(estrComp)$\rangle$)}
    $res \gets$ vacia()\;
    \tipo{itConj(interfaz)} $it \gets$ crearIt(ci)\;
    \While{haySiguiente($it$)}{
      agregarAtras($res$, $\langle$siguiente($it$), NULL$\rangle$)\;
      avanzar($it$)\;
    }
  \end{algoritmo}
  
  \begin{algoritmo}{iConectar}{\Inout{r}{estrRed)}, \In{c_{0}}{estrCompu}, \In{i_{0}}{interfaz}, \In{c_{1}}{estrCompu}, \In{i_{1}}{interfaz}}{}
    \tipo{itLista(estrComp)} $it_{0} \gets$ crearIt(r.compus)\;
    \tipo{itLista(estrComp)} $it_{1} \gets$ crearIt(r.compus)\;
    \While{siguiente($it_{0}$.IP $\neq$ $c_{0}$.IP)}{
      avanzar($it_{0}$)\;
    }
   \While{siguiente($it_{1}$.IP $\neq$ $c_{1}$.IP)}{
      avanzar($it_{1}$)\;
    }

    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{2} \gets$ crearIt(siguiente($it_{0}$.conexiones))\;
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{3} \gets$ crearIt(siguiente($it_{1}$.conexiones))\;

   \While{siguiente($it_{2}$.inter $\neq$ $i_{0}$)}{
      avanzar($it_{2}$)\;
    }
   \While{siguiente($it_{3}$.inter $\neq$ $i_{1}$)}{
      avanzar($it_{3}$)\;
    }

    siguiente($it_{2}$).itCompu $\gets$ $i_{0}$
    siguiente($it_{3}$).itCompu $\gets$ $i_{1}$
  \end{algoritmo}

  \begin{algoritmo}{iCrearConjuntoDeInterfaces}{\In{l}{lista(tupla(interfaz, itLista(estrCompu)))}}{conj(estrInterfaz)}{}
    \tipo{nat} $n \gets$ 0\;
    $res \gets$ vacio()\;
   \While{n < longitud(l)}{
      agregar($res$, $\Pi_{1}$(l[n]))\;
      $n \gets n+1$\;
    }
  \end{algoritmo}  
  
  \begin{algoritmo}{iConectadas?}{\In{r}{estrRed}, \In{c_{0}}{estrCompu}, \In{c_{1}}{estrCompu}}{bool}{}
    \tipo{itLista(estrComp)} $it_{0} \gets$ crearIt(r.compus)\;
    \While{siguiente($it_{0}$).IP $\neq c_{0}$.IP}{
      avanzar($it_{0}$)\;
    }
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{1} \gets$ crearIt(siguiente($it_{0}$.conexiones))\;
    \While{haySiguiente($it_{1}$) $\yluego$ siguiente(siguiente($it_{1}$).itCompu).IP $\neq c_{1}$.IP}{
      avanzar($it_{1}$)\;
    }
    $res \gets$ (siguiente(siguiente($it_{1}$).itCompu).IP $= c_{1}$.IP)\;
  \end{algoritmo}  

  \begin{algoritmo}{iInterfazUsada}{\In{r}{estrRed}, \In{c_{0}}{estrCompu}, \In{c_{1}}{estrCompu}}{interfaz}{}
    \tipo{itLista(estrComp)} $it_{0} \gets$ crearIt(r.compus)\;
    \While{siguiente($it_{0}$).IP $\neq c_{0}$.IP}{
      avanzar($it_{0}$)\;
    }
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{1} \gets$ crearIt(siguiente($it_{0}$.conexiones))\;
    \While{haySiguiente($it_{1}$) $\yluego$ siguiente(siguiente($it_{1}$).itCompu).IP $\neq c_{1}$.IP}{
      avanzar($it_{1}$)\;
    }
    $res \gets$ siguiente($it_{1}$).inter\;
  \end{algoritmo}  
    
  \begin{algoritmo}{iVecinos}{\In{r}{estrRed}, \In{c}{estrCompu}}{conj(compu)}{}
    $res \gets$ vacio() \;
    \tipo{itLista(estrComp)} $it_{0} \gets$ crearIt(r.compus)\;
    \While{siguiente($it_{0}$).IP $\neq c$.IP}{
      avanzar($it_{0}$)\;
    }
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{1} \gets$ crearIt(siguiente($it_{0}$.conexiones))\;
    \While{haySiguiente?($it_{1}$)}{
      \If{haySiguiente?(siguiente($it_{1}$).itCompu)}{
        agregar($res$, siguiente(siguiente($it_{1}$).itCompu))\;
      }
      avanzar($it_{1}$)\;
    }
  \end{algoritmo}

  \begin{algoritmo}{iUsaInterfaz?}{\In{r}{estrRed}, \In{c}{estrCompu}, \In{i}{interfaz}}{bool}{}
    \tipo{itLista(estrComp)} $it_{0} \gets$ crearIt(r.compus)\;
    \While{siguiente($it_{0}$).IP $\neq c$.IP}{
      avanzar($it_{0}$)\;
    }
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{1} \gets$ crearIt(siguiente($it_{0}$.conexiones))\;
    \While{siguiente($it_{1}$).inter $\neq i$}{
     avanzar($it_{1}$)\;
    }
    $res \gets$ haySiguiente?(siguiente($it_{1}$).itCompu)\;
  \end{algoritmo}

  \begin{algoritmo}{iCaminosMinimos}{\In{r}{estrRed}, \In{c_{0}}{estrCompu}, \In{c_{1}}{estrCompu}}{conj(lista(estrCompu))}{}
    $res \gets$ vacio()\;
    \eIf{pertenece($c_{1}$, vecinos($r$, $c_{1}$))}{
      agregar($res$, agregarAtras(agregarAtras(<>,$c_{0}$), $c_{1}$))\;
    }{
      $res \gets$ dameMinimos(iCaminos($r$, $c_{0}$, $c_{1}$, agregarAtras(<>,$c_{0}$), pasarConjASecu(vecinos($r$, $c_{0}$))))\;
    }

  \end{algoritmo}

  \begin{algoritmo}{iHayCaminos?}{\In{r}{estrRed}, \In{c_{0}}{estrCompu}, \In{c_{1}}{estrCompu}}{bool}{}
    $res \gets$ esVacio?(iCaminosMinimos($r$, $c_{0}$, $c_{1}$))
  \end{algoritmo}

  \begin{algoritmo}{iCaminos}{\In{r}{estrRed}, \In{c_{0}}{estrCompu}, \In{c_{1}}{estrCompu}, \In{l}{lista(estrCompu)}, \In{vec}{lista(estrCompu)}}{conj(lista(estrCompu))}{}
    \eIf{vacia?($vec$)}{
      $res \gets$ vacia()\;
    }{
      \eIf{/'{u}ltimo($l$) = $c_{1}$}{
        $res \gets$ agregar($l$, vacia())\;
      }{
        \eIf{$\not$est\'{a}?(primero($vec$, $l$))}{
          $res \gets$ uni\'{o}n(caminos($r$, $c_{0}$, $c_{1}$, agregarAtras($l$, primero($vec$)), iVecinos($r$, primeros($vec$))), caminos($r$, $c_{0}$, $c_{1}$, $l$, fin($vec$)))\;
        }{
          $res \gets$ caminos($r$, $c_{0}$, $c_{1}$, $l$, fin($vec$))\;
        }
      }
    }
  \end{algoritmo}
  
  \begin{algoritmo}{iComputadoras}{\In{r}{estrRed}}{conj(estrCompu)}{}
    $res \gets$ vacio()\;
    \tipo{itRed} $it \gets$ crearItRed()\;
    \While{haySiguiente?($it$)}{
      agregar($res$, siguiente($it$))\;
      avanzar($it$)\;
    }
  \end{algoritmo}

  \begin{algoritmo}{iHaySiguiente?}{\In{it}{itLista(estrCompu)}}{bool}{}
  $res \gets$ haySiguiente?($it$)\;
  \end{algoritmo}

  \begin{algoritmo}{iSiguiente}{\In{it}{itLista(estrCompu)}}{compu}{}
    \tipo{estrCompu} $e \gets$ siguiente($it$)\;
    $res$.IP $\gets$ $e$.IP\;
    \tipo{conoj(interfaz)} $interfaces \gets$ vac\'{i}o()\;
    \tipo{itLista(tupla$\langle$ $inter$: interfaz, $itCompu$: itLista(estrCompu)$\rangle$)} $itInterfaces \gets$ crearIt($e$.conexiones)\;
    \While{haySiguiente?($itInterfaces$)}{
      agregar($interfaces$, siguiente($itInterfaces$).inter)\;
      avanzar($itInterfaces$)\;
    }
    $res$.Interfaces $\gets$ $e$.Interfaces\;
  \end{algoritmo}

  \begin{algoritmo}{iCrearIt}{\In{e}{estrRed}}{}{}
  $res \gets$ crearIt($e$.compus)\;
  \end{algoritmo}

  \begin{algoritmo}{iAvanzar}{\Inout{it}{itLista(estrCompu)}}{}{}
  $it \gets$ avanzar($it$)\;
  \end{algoritmo}
\end{Algoritmos}
