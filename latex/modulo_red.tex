\section{M\'{o}dulo Red}

\Encabezado{Notas preliminares}
  En todos los casos, al indicar las complejidades de los algoritmos, las variables que se utilizan corresponden a:
  \vspace{-0.5em}\begin{itemize}
    \item $n$: N\'umero de computadoras en la red.
    \item $L$: Longitud de nombre de computadora m\'as largo de la red.
    \item $I$: Mayor cantidad de interfaces que tiene alguna computadora en la red en el momento.
  \end{itemize}

\servUsados{interfaz, tupla, nat, IP, lista}

\begin{Interfaz}
  
  % IMPORTANTE: Hay que arreglar las complejidades.

  \seExplicaCon{Red}

  \generos{\tipo{red}}
  
  \Encabezado{Operaciones del TAD Red}

  \InterfazFuncion{iniciarRed}{}{Red}
  [] % Pre
  {res $\igobs$ iniciarRed()} % Pos
  [$\Theta(1)$] % Complejidad
  [Genera una nueva red sin ninguna computadora.] % Descripción
  [] % Aliasing
  
  \InterfazFuncion{agregarCompu}{\Inout{r}{Red}, \In{c}{compu}}{}
  [$r$ $\igobs$ $r_{0}$ $\land$ ($\forall c'$: compu)($c' \in$ computadoras($r$) $\rightarrow$ ip($c$) $\neq$ ip($c'$))] % Pre
  {$r$ $\igobs$ agregarCompu($r_{0}$, c)} % Pos
  [$\Theta(I)$] % Complejidad
  [Agrega una nueva computadora a la red.] % Descripción
  [] % Aliasing

  \InterfazFuncion{conectar}{\Inout{r}{Red}, \In{c_0}{compu}, \In{i_0}{interfaz}, \In{c_1}{compu}, \In{i_1}{interfaz}}{Red}
  [$r$ $\igobs$ $r_{0}$ $\land$ $c_{1} \in$ computadoras($r$) $\land$ $c_{2} \in$ computadoras($r$) $\land$ ip($c_{0} $) $\neq$ ip($c_{1}$) $\land$ $\lnot$conectadas?($r$, $c_{0}$ , $c_{1} $) $\land$ $\lnot$usaInterfaz?($r$, $c_{0}$, $i_{0}$) $\land$ $\lnot$usaInterfaz?($r$, $c_{1}$, $i_{1}$)] % Pre
  {$r$ $\igobs$ conectar($r_{0}$, $c_{0}$, $i_{0}$, $c_{1}$, $i_{1}$)} % Pos
  [$\Theta(n+I)$] % Complejidad
  [Conecta la computadora $c_{0}$ con la computadora $c_{1}$ a trav\'es de las interfaces $i_{0}$ y $i_{1}$ respectivamente. ] % Descripción
  [] % Aliasing
  
  \InterfazFuncion{computadoras}{\In{r}{Red}}{conj(compu)}
  [] % Pre
  {esAlias($res$, computadoras(r))} % Pos
  [$\Theta(1)$] % Complejidad
  [Devuelve el conjunto de todas las computadoras de la red. ] % Descripción
  [El conjunto es devuelto por referencia.] % Aliasing
  
  \InterfazFuncion{conectadas?}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{bool}
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)] % Pre
  {$res$ $\igobs$ conectadas?($r$, $c_{0}$, $c_{1}$)} % Pos
  [$\Theta(n+I)$] % Complejidad
  [Devuelve \emph{true} si y solo si la computadora $c_{0}$ esta conectada a la computadora $c_{1}$] % Descripción
  [] % Aliasing
  
  \InterfazFuncion{interfazUsada}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{interfaz}
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$) $\yluego$ conectadas?($r$, $c_{0}$, $c_{1}$)] % Pre
  {$res$ $\igobs$ interfazUsada($r$, $c_{0}$, $c_{1}$)} % Pos
  [$\Theta(n+I)$] % Complejidad
  [Devuelve la interfaz usada por $c_{0}$ para conectarse a $c_{1}$] % Descripción
  [] % Aliasing
  
  \InterfazFuncion{vecinos}{\In{r}{Red}, \In{c}{compu}}{conj(compu)}
  [$c$ $\in$ computadoras($r$)] % Pre
  {$res$ $\igobs$ vecinos($r$, $c$)} % Pos
  [$\Theta(n+I³)$] % Complejidad
  [Devuelve el conjunto de vecinos de la computadora $c$, es decir, las computadoras que tienen una conexi\'on directa con $c$.] % Descripción
  [Devuelve el conjunto por copia.] % Aliasing
  
  \InterfazFuncion{usaInterfaz?}{\In{r}{Red}, \In{c}{compu}, \In{i}{interfaz}}{bool}
  [$c$ $\in$ computadoras($r$)] % Pre
  {$res$ $\igobs$ usaInterfaz?($r$, $c$, $i$)} % Pos
  [$\Theta(n+I)$] % Complejidad
  [Devuelve \emph{true} si y solo si la computadora $c$ est\'a usando la interfaz $i$.] % Descripción
  [] % Aliasing
  
  \InterfazFuncion{caminosMinimos}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{conj(secu(compu))}
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)] % Pre
  {$res$ $\igobs$ caminosMinimos($r$, $c_{0}$, $c_{1}$)} % Pos
  [$\Theta(n³ \times n! \times n! + I)$] % Complejidad
  [Devuelve el conjunto de todos los caminos m\'nimos posibles entre $c_{0}$ y $c_{1}$. De no haber ninguno, devuelve $\emptyset$.] % Descripción
  [Devuelve el conjunto por copia.] % Aliasing
  
  \InterfazFuncion{hayCamino?}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{bool}
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)] % Pre
  {$res$ $\igobs$ hayCamino?($r$, $c_{0}$, $c_{1}$)} % Pos
  [$\Theta(n² \times n!)$] % Complejidad
  [Devuelve \emph{true} si y solo si hay al menos un camino posible entre $c_{0}$ y $c_{1}$. ] % Descripción
  [] % Aliasing
  
  \InterfazFuncion{cantCompus}{\In{r}{Red}}{nat}
  [true] % Pre
  {$res$ $\igobs$ \#(computadoras(r))} % Pos
  [$\Theta(1)$] % Complejidad
  [Devuelve cu\'antas computadoras hay en la red.] % Descripción
  [] % Aliasing

  \InterfazFuncion{copiar}{\In{r}{Red}}{Red}
  [true] % Pre
  {$res$ $\igobs$ $r$} % Pos
  [$\Theta(n \times I)$] % Complejidad
  [Devuelve una copia de la red.] % Descripción
  [] % Aliasing

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{red}[estrRed]

    \begin{Tupla}[estrRed]
      \tupItem{compus}{conjunto(compu)}
      \tupItem{conexiones}{dicc(IP, diccConexiones)}
    \end{Tupla}

    \hspace*{3mm}donde \TipoVariable{diccConexiones} es \TipoVariable{dicc(interfaz, itDicc(IP, diccConexiones))}

  \end{Estructura}


\textbf{Rep en castellano:}

    \begin{enumerate} 
      \item El cardinal del conjunto de claves del diccionario Conexiones, es igual al cardinal del conjunto de compus.
      \item Ninguna compu tiene vecinos repetidos.
      \item Ninguna compu puede ser vecina de si misma.
      \item Todos los vecinos tienen que estar en el conjunto de claves del diccionario Conexiones.
      \item Si $c_{1}$ y $c_{2}$ son computadoras de la red, $c_{1}$ es vecina de $c_{2}$ si y solo si $c_{2}$ es vecina de $c_{1}$.
      \item El conjunto de compus es el mismo que el que resulta de armar las computadoras con los diccionarios.
    \end{enumerate}

  \RepFc[Red][e]{ 
  \begin{enumerate} 
      \item $\#$claves($e$.conexiones)=$\#$($e$.compus) $\land$
      \item ($\forall c$: IP) $c$ $\in$ claves($e$.conexiones) $\impluego$ sinRepetidos(JuntarSignificados(obtener($c$, $e$.conexiones))) $\land$
      \item ($\forall c$: IP) $c$ $\in$ claves($e$.conexiones) $\impluego$ $\neg$esta?($c$, JuntarSignificados(obtener($c$, $e$.conexiones))) $\land$
      \item ($\forall c_{1}$:IP) $c$ $\in$ claves($e$.conexiones) $\impluego$ ($\forall c_{2}$:IP) esta?($c_{2}$, JuntarSignificados(obtener($c_{1}$, $e$.conexiones))) $c_{2}$ $\Rightarrow$ ($e$.conexiones) $\yluego$
      \item ($\forall c_{1}$:IP) ($\forall c_{2}$:IP) ($c_{1}$ $\in$ claves($e$.conexiones)) $\land$ ($c_{2}$ $\in$ claves($e$.conexiones)) $\impluego$ esta?($c_{1}$, JuntarSignificados(obtener($c_{2}$, $e$.conexiones))) $\Leftrightarrow$ esta?($c_{2}$, JuntarSignificados(obtener($c_{1}$, $e$.conexiones))) $\land$
      \item ($\forall c$: IP) $c$ $\in$ $e$.compus $\Rightarrow$ $\Pi_{1}$($c$) $\in$ claves($e$.conexiones) $\yluego$ claves(obtener($\Pi_{1}$($c$), $e$.conexiones)) $\subseteq$ $\Pi_{2}$($c$)


      \end{enumerate}
    }\mbox{}

  ~

  \AbsFc[estrRed]{Red}[e]{(r: Red | computadoras(r) = $e$.compus $\land$ \\
    ($\forall c_{1}$: compu)(($\forall c_{2}$: compu) conectados?(r, $c_{1}$, $c_{2}$) = esta?($c_{2}$, JuntarSignificados(Obtener($c_{1}$, $e$.conexiones))) $\land$ \\
    ($\forall c_{1}$: compu)(($\forall c_{2}$: compu) InterfazUsada(r, $c_{1}$, $c_{2}$) = DameClave(Obtener($c_{1}$, $e$.conexiones), $c_{2}$))
  }
  
  ~

  \textbf{Funciones Auxiliares:}

  ~
    
  \tadOperacion{sinRepetidos}{secu(nat)}{bool}{}
  \tadAxioma{sinRepetidos($s$)}{$\#$(pasarSecuAConj($s$)) $=$ long($s$)}

  ~
    
  \tadOperacion{pasarSecuAConj}{secu(nat)}{conj(nat)}{}
  \tadAxioma{pasarSecuAConj($s$)}{\IF vacia?($s$) THEN $\emptyset$ ELSE Ag(prim($s$), pasarSecuAConj(fin($s$))) FI}

  ~

  \tadOperacion{JuntarSignificados}{dicc(Interfaz{,} IP)}{secu(IP)}{}
  \tadAxioma{JuntarSignificados($d$)}{JuntarSignificados\fAux($d$, claves($d$))}

  ~

  \tadOperacion{JuntarSignificados\fAux}{dicc(Interfaz{,} IP), conj(Interfaz)}{secu(IP)}{}
  \tadAxioma{JuntarSignificados\fAux($d$, $Is$)}{\IF $\emptyset$?($Is$) THEN <> ELSE obtener(dameUno($Is$, $d$)) $\puntito$ JuntarSignificados\fAux($d$, sinUno($Is$)) FI}

  ~

  \tadOperacion{DameClave}{dicc(Interfaz{,} IP)/$d$, IP/$c$}{Interfaz}{esta?($c$, JuntarSignificados($d$))}
  \tadAxioma{DameClave($d$, $c$)}{DameClave\fAux($d$, claves($d$), $c$)}

  ~

  \tadOperacion{DameClave\fAux}{dicc(Interfaz{,} IP)/$d$, conj(Interfaz)/$Is$, IP/$c$}{Interfaz}{esta?($c$, JuntarSignificados($d$))}
  \tadAxioma{DameClave\fAux($d$, $Is$, $c$)}{\IF (obtener(dameUno($Is$))$=c$) THEN dameUno($Is$) ELSE DameClave\fAux($d$, sinUno($Is$), $c$) FI}

  ~

\end{Representacion}

\begin{Algoritmos}

  \nuevoAlgo
  \begin{algoritmo}{iIniciarRed}{}{estrRed}
    $res \gets \langle$\vacio{}, \vacio{}$\rangle$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificacíón

  \nuevoAlgo
  \begin{algoritmo}{iAgregarCompu}{\Inout{r}{estrRed}, \In{c}{compu}}{}
    \agRap{$r.compus$, $c$} \com*{$\Theta(1)$}
    \defRap{$r.conexiones$, $c.IP$, \vacio{}} \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificacíón

  % Esta operación tal vez ya no sea necesaria:
  
  % \begin{algoritmo}{iArmarLista}{\In{c}{conj(interfaz)}}{lista($\langle$Interfaz, itLista(estrCompu)$\rangle$)}
  %   $res \gets$ vacia()\com*{$\Theta(1)$}
  %   \tipo{itConj(interfaz)} $it \gets$ crearIt(c)\com*{$\Theta(1)$}
  %   \While(\com*[f]{$\Theta(I)$ iteraciones}){haySiguiente($it$)}{
  %     agregarAtras($res$, $\langle$siguiente($it$), NULL$\rangle$)\com*{$\Theta(1)$}
  %     avanzar($it$)\com*{$\Theta(1)$}
  %   }
  % \end{algoritmo}
  % \datosAlgoritmo{Dado un conjunto de interfaces, arma una lista, que representa las computadoras sin conexiones como tuplas de Interfaz e Iterador a NULL (ya que cuando una computadora se agrega a la red no est\'{a} conectada a ninguna otra)} % Descripción
  % {} % Pre
  % {} % Post
  % {$\Theta(I)$} % Complejidad
  % {} % Justificacíón
  
  \nuevoAlgo
  \begin{algoritmo}{iConectar}{\Inout{r}{estrRed)}, \In{c_{1}}{compu}, \In{i_{1}}{interfaz}, \In{c_{2}}{compu}, \In{i_{2}}{interfaz}}{}
    \defRap($i_{1}$, $c_{2}$.IP, significado($r$.conexiones, $c_{1}$))
    \defRap($i_{2}$, $c_{1}$.IP, significado($r$.conexiones, $c_{2}$))
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificacíón
  
  \nuevoAlgo
  \begin{algoritmo}{iConectadas?}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{bool}{}
    \tipo{dicc(Interfaz, IP)} $d \gets$ significado($c_1$, $r$.conexiones) \com*{$\Theta(L)$}
    \tipo{ItDicc(Interfaz, IP)} $it \gets$ crearIt($d$) \com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){haySiguiente(it) $\yluego$ siguienteSignificado(it) $\neq$ $c_2$}{
      \avanzar{$it_1$} \com*{$\Theta(1)$}
    }
    $res \gets$ \haySig{$it$} \com*{$\Theta(1)$}
  \end{algoritmo}  
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(L+I)$} % Complejidad
  {} % Justificacíón

  \nuevoAlgo
  \begin{algoritmo}{iInterfazUsada}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{interfaz}{}
    \tipo{dicc(Interfaz, IP)} $d \gets$ significado($c_1$, $r$.conexiones) \com*{$\Theta(L)$}
    \tipo{ItDicc(Interfaz, IP)} $it \gets$ crearIt($d$) \com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){\sigSignif($it$) $\neq$ $c_2$}{
      \avanzar{$it_1$} \com*{$\Theta(1)$}
    }
    $res \gets$ \sigClave($it$) \com*{$\Theta(1)$}
  \end{algoritmo}  
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(L+I)$} % Complejidad
  {} % Justificacíón
    
  \begin{algoritmo}{iVecinos}{\In{r}{estrRed}, \In{c}{compu}}{conj(compu)}{}
    \tipo{dicc(Interfaz, IP)} $d \gets$ significado($c_1$, $r$.conexiones) \com*{$\Theta(L)$}
    \tipo{ItDicc(Interfaz, IP)} $it_1 \gets$ crearIt($d$) \com*{$\Theta(1)$}
    $res \gets$ vacio() \com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){haySiguiente?($it_1$)}{
      \tipo{ItConj} $it_2 \gets$ crearIt($r$.compus) com*{$\Theta(1)$}
      \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_2$).IP $\neq$ \sigClave($it_1$)}{
        avanzar($it_2$)
      }
      \agRap{res, siguiente($it_2$)}
     } 
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(L+I \times N)$} % Complejidad
  {} % Justificacíón
  

  % Esta operación tal vez ya no sea necesaria:
  % \begin{algoritmo}{iCrearConjunto}{\In{l}{lista(tupla($inter$: interfaz, $com$: itLista(estrCompu)))}}{conj(interfaz)}{}
  %  \tipo{nat} $n \gets$ 0\com*{$\Theta(1)$}
  %  $res \gets$ vacio()\com*{$\Theta(1)$}
  % \While(\com*[f]{$\Theta(I)$ iteraciones}){n < longitud(l)}{
  %    agregar($res$, (l[n]).inter)\com*{$\Theta(I)$}
  %    $n \gets n+1$\com*{$\Theta(1)$}
  %  }
 % \end{algoritmo} 
 % \datosAlgoritmo{Dada una lista de tupla de $\langle$Interfaz,Iterador$\rangle$ (que representa las conexiones de la computadora), devuelve el conjunto de todas las interfaces que se encuentran en ella. } % Descripción
 % {} % Pre
 % {} % Post
 % {$\Theta(I²)$} % Complejidad
 % {} % Justificacíón

  \begin{algoritmo}{iUsaInterfaz?}{\In{r}{estrRed}, \In{c}{compu}, \In{i}{interfaz}}{bool}{}
    $res \gets$ definido?(significado($c$, $r$.conexiones), $i$) 
  \end{algoritmo} \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificacíón
   
  \begin{algoritmo}{iCaminosMinimos}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{conj(lista(compu))}{}
    $res \gets$ vacio()\com*{$\Theta(1)$}
    \eIf(\com*[f]{$\Theta(I)$}){pertenece?($c_{2}$, vecinos($r$, $c_{1}$))}{
      agregar($res$, agregarAtras(agregarAtras(<>,$c_{1}$), $c_{2}$))\com*{$\Theta(n+I)$}
    }{
      $res \gets$ dameMinimos(Caminos($r$, $c_{1}$, $c_{2}$, agregarAtras(<>,$c_{1}$), pasarConjASecu(vecinos($r$, $c_{1}$))))\com*{$\Theta(n³ \times n! \times n!)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n³ \times n! \times n! + I$)} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{dameMinimos}{\In{c}{conj(lista(compu))}}{conj(lista(compu))}
    \eIf(\com*[f]{$\Theta(1)$}){esVacio?($c$)}{
      $res \gets$ vacio()\com*{$\Theta(1)$}
    }{
      \tipo{itConj(lista(compu))} $it \gets$ crearIt(c)\com*{$\Theta(1)$}
      $res \gets$ dameMinimosAux($c$, minimaLong($c$, long(siguiente($it$))))\com*{$\Theta(n \times n!)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{Devuelve, del total de caminos posibles, solo los de longitud m\'{i}nima} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n \times n!)$} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{dameMinimosAux}{\In{c}{conj(lista(compu))}, \In{n}{nat}}{conj(lista(compu))}
    \tipo{itConj(lista(compu))} $it \gets$ crearIt($c$)\com*{$\Theta(1)$}
    $res \gets$ vacio() \com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n!)$ iteraciones}){haySiguiente($it$)}{
      \eIf(\com*[f]{$\Theta(1)$}){long(siguiente($it$))$=n$}{
        agregar($res$, siguiente($it$))\com*{$\Theta(n)$}
        avanzar($it$) \com*{$\Theta(1)$}
      }{
        avanzar($it$) \com*{$\Theta(1)$}
      }
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n \times n!)$} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{minimaLong}{\In{c}{conj(lista(compu))}, \In{n}{nat}}{nat}
    \tipo{nat} $i \gets n$\com*{$\Theta(1)$}
    \tipo{itConj(lista(compu))} $it \gets$ crearIt($c$)\com*{$\Theta(1)$}
    \While{haySiguiente($it$)}{
      \eIf{long(siguiente($it$))}{
        $i \gets$ longitud(siguiente($it$))\com*{$\Theta(1)$}
        avanzar($it$)\com*{$\Theta(1)$}
      }{
        avanzar($it$)\com*{$\Theta(1)$}
      }
    }
    $res \gets i$\com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n!)$} % Complejidad
  {Devuelve la longitud de la secuencia m\'{a}s chica} % Justificacíón
    
	\begin{algoritmo}{pasarConjASecu}{\In{c}{conj(compu)}}{secu(compu)}{}
		$res \gets$ vacia()\com*{$\Theta(1)$}
		\tipo{ItConj} $it \gets$ crearIt(c)\com*{$\Theta(1)$}
		\While(\com*[f]{$\Theta(n)$ iteraciones}){haySiguiente($it$)}{
			agregarAtras($res$, siguiente($it$))\com*{$\Theta(I)$} 		
		}
	\end{algoritmo}    
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n \times I)$} % Complejidad
  {Devuelve una secuencia que contiene a todos los elementos del conjunto pasado por par\'{a}metro} % Justificacíón
     
  \begin{algoritmo}{iHayCamino?}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{bool}{}
    $res \gets$ ($\neg$esVacio?(iCaminosMinimos($r$, $c_{1}$, $c_{2}$))) \com*{$\Theta(n² \times n!)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n² \times n!)$} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{iCaminos}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}, \In{l}{lista(estrCompu)}, \In{vec}{lista(estrCompu)}}{conj(lista(estrCompu))}{}
    \eIf{vacia?($vec$)}{
      $res \gets$ vacia()\;
    }{
      \eIf{\'{u}ltimo($l$) = $c_{1}$}{
        $res \gets$ agregar($l$, vacia())\;
      }{
        \eIf{$\neg$est\'{a}?(primero($vec$, $l$))}{
          $res \gets$ uni\'{o}n(caminos($r$, $c_{0}$, $c_{1}$, agregarAtras($l$, primero($vec$)), Vecinos($r$, primeros($vec$))), caminos($r$, $c_{0}$, $c_{1}$, $l$, fin($vec$)))\;
        }{
          $res \gets$ caminos($r$, $c_{0}$, $c_{1}$, $l$, fin($vec$))\;
        }
      }
    }
  \end{algoritmo}
  \datosAlgoritmo{Dada una red, dos compus, los vecinos de la primer compu, y una lista que usamos para guardar las computadoras por las que ya preguntamos, iteramos sobre todas las computadoras y devolvemos el conjunto de todos los caminos posibles desde la primer computadora hasta la segunda. } % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n² \times n!)$} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{iUni\'{o}n}{\In{c_{1}}{conj(lista(compu))}, \In{c_{2}}{conj(lista(compu))}}{conj(lista(compu))}
    $res \gets$ vacio()\com*{$\Theta(1)$}     
    \eIf(\com*[f]{$\Theta(1)$}){vacio?($c_{1}$)}{
      $res \gets$ $c_{2}$\com*{$\Theta(I \times n \times n!)$} 
      }{
      \tipo{itConj(lista(compu))} $it \gets$ crearIt($c_{1}$)\com*{$\Theta(1)$}     
      \While(\com*[f]{$\Theta(n)$}){haySiguiente($it$)}{
        Ag(siguiente($it$), $c_{2}$)\com*{$\Theta(n)$}
        avanzar(it)\com*{$\Theta(1)$}
      } 
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n² + n \times I \times n!)$} % Complejidad
  {Devuelve la uni\'{o}n de dos conjuntos. } % Justificacíón

  \begin{algoritmo}{iEsta?}{\In{c}{compu}, \In{l}{lista(compu)}}{bool}
    \eIf(\com*[f]{$\Theta(1)$}){vacia?($l$)}{
      $res \gets$ false\com*{$\Theta(1)$}
    }{
    \tipo{ItLista(compu)} $it \gets$ crearIt($l$)\com*{$\Theta(1)$}
      \While(\com*{$\Theta(n)$}){haySiguiente($it$) $\yluego$ siguiente($it$) $\neq$ $c$}{
        avanzar(it)\com*{$\Theta(1)$}
      }
    }
    $res \gets$ (haySiguiente($it$))\com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{Devuelve True si y solo si la compu $c$ se encuentra en la lista l} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n)$} % Complejidad
  {.} % Justificacíón

  \begin{algoritmo}{iComputadoras}{\In{r}{estrRed}}{conj(compu)}{}
    $res \gets$ vacio()\com*{$\Theta(1)$}
    \tipo{itRed} $it \gets$ crearItRed()\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){haySiguiente?($it$)}{
      agregar($res$, siguiente($it$))\com*{$\Theta(n+I²)$}
      avanzar($it$)\com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n \times (n+I²))$} % Complejidad
  {} % Justificacíón
   
  \begin{algoritmo}{iCopiar}{\In r:estrRed}{Red}
   	$res \gets$ $\langle$copiar(r.compus, r.cantidadCompus$\rangle$\com*{$\Theta(n \times I)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n \times I)$} % Complejidad
  {Devuelve una copia de la Red} % Justificacíón

  \begin{algoritmo}{iCantCompus}{\In{r}{Red}}{nat}
    $res \gets$ $r$.cantCompus\com*{$\Theta(1)$}
  \end{algoritmo}   
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificacíón

\end{Algoritmos}
