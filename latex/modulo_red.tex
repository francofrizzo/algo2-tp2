\section{M\'{o}dulo Red}

\Encabezado{Notas preliminares}
  En todos los casos, al indicar las complejidades de los algoritmos, las variables que se utilizan corresponden a:
  \vspace{-0.5em}\begin{itemize}
    \item $n$: N\'umero de computadoras en la red.
    \item $L$: Longitud de nombre de computadora m\'as largo de la red.
    \item $i$: Mayor cantidad de interfaces que tiene alguna computadora en la red en el momento.
  \end{itemize}

\begin{Interfaz}
  
  \seExplicaCon{Red, Iterador Unidireccional(Compu)}

  \generos{\tipo{red}, \tipo{itRed}}
  
  \Encabezado{Operaciones b\'{a}sicas de Red}

  \InterfazFuncion{iniciarRed}{}{Red}%
  {res $\igobs$ iniciarRed()}%pos
  [$\Theta(1234)$]%complejidad
  [Genera una nueva red sin ninguna computadora.]%descripcion
  []%aliasing
  
  \InterfazFuncion{agregarCompu}{\Inout{r}{Red}, \In{c}{compu}}{}%
  [$r$ $\igobs$ $r_{0}$ $\land$ ($\forall c'$: compu)($c' \in$ computadoras($r$) $\rightarrow$ ip($c$) $\neq$ ip($c'$))]%pre
  {$r$ $\igobs$ agregarCompu($r_{0}$, c)}%pos
  [$\Theta(1324)$]%complejidad
  [Agrega una nueva pc a una red.]%descripcion
  []%aliasing

  \InterfazFuncion{conectar}{\Inout{r}{Red}, \In{c_0}{compu}, \In{i_0}{interfaz}, \In{c_1}{compu}, \In{i_1}{interfaz}}{Red}%
  [$r$ $\igobs$ $r_{0}$ $\land$ $c_{1} \in$ computadoras($r$) $\land$ $c_{2} \in$ computadoras($r$) $\land$ ip($c_{0} $) $\neq$ ip($c_{1}$) $\land$ $\lnot$conectadas?($r$, $c_{0}$ , $c_{1} $) $\land$ $\lnot$usaInterfaz?($r$, $c_{0}$, $i_{0}$) $\land$ $\lnot$usaInterfaz?($r$, $c_{1}$, $i_{1}$)]%pre
  {$r$ $\igobs$ conectar($r_{0}$, $c_{0}$, $i_{0}$, $c_{1}$, $i_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Conecta la pc $c_{0}$ con la pc $c_{1}$ a trav\'es de las interfaces $i_{0}$ y $i_{1}$ respectivamente. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{computadoras}{\In{r}{Red}}{conj(compu)}%
  {$res$ $\igobs$ computadoras(r)} %es alias(res,compus(R))             %pos
  [$\Theta(1234)$]%complejidad
  [Devuelve todas las computadoras de la red. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{conectadas?}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{bool}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)]%pre
  {$res$ $\igobs$ conectadas?($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve true si y solo si la pc $c_{0}$ esta conectada a la pc $c_{1}$]%descripcion
  []%aliasing
  
  \InterfazFuncion{interfazUsada}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{interfaz}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$) $\yluego$ conectadas?($r$, $c_{0}$, $c_{1}$)]%pre
  {$res$ $\igobs$ interfazUsada($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve la interfaz usada por $c_{0}$ para conectarse a $c_{1}$]%descripcion
  []%aliasing
  
  \InterfazFuncion{vecinos}{\In{r}{Red}, \In{c}{compu}}{conj(compu)}%
  [$c$ $\in$ computadoras($r$)]%pre
  {$res$ $\igobs$ vecinos($r$, $c$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve el conjunto de vecinos de la pc $c$]%descripcion
  []%aliasing
  
  \InterfazFuncion{usaInterfaz?}{\In{r}{Red}, \In{c}{compu}, \In{i}{interfaz}}{bool}%
  [$c$ $\in$ computadoras($r$)]%pre
  {$res$ $\igobs$ usaInterfaz?($r$, $c$, $i$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve true si y solo si la pc $c$ esta usando la interfaz $i$. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{caminosMinimos}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{conj(secu(compu))}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)]%pre
  {$res$ $\igobs$ caminosMinimos($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve todos los caminos m\'nimos posibles entre $c_{0}$ y $c_{1}$. De no haber ninguno, devuelve $\emptyset$. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{hayCamino?}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{bool}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)]%pre
  {$res$ $\igobs$ hayCamino?($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve true si y solo si hay alg\'un camino posible entre $c_{0}$ y $c_{1}$. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{copiar}{\In{r}{Red}}{Red}%
  [true]%pre
  {$res$ $\igobs$ $r$}%pos
  [$\Theta(n \times I)$]%complejidad
  [Devuelve una copia de la red]%descripcion
  []%aliasing

  \Encabezado{Operaciones b\'{a}sicas del iterador de Red}

  \InterfazFuncion{crearIt}{\In{r}{Red}}{itRed}%
  [true]%pre
  {$res$ $\igobs$ crearItUni($r$.compus)}%pos
  [$\Theta(1)$]%complejidad
  [Crea un iterador de red.  ]%descripcion
  [??????????]%aliasing

  \InterfazFuncion{haySiguiente?}{\In{it}{itRed}}{bool}%
  [true]%pre
  {$res$ $\igobs$ hayMas?($it$)}%pos
  [$\Theta(1)$]%complejidad
  [Devuelve true si y solo si $it$ tiene siguiente. ]%descripcion
  []%aliasing

  \InterfazFuncion{siguiente}{\In{it}{itRed}}{compu}%
  [true]%pre
  {$res$ $\igobs$ actual($it$)}%pos
  [$\Theta(1)$]%complejidad
  [??????????. ]%descripcion
  [$res$ se devuelve por referencia]%aliasing

  \InterfazFuncion{avanzar}{\Inout{it}{itRed}}{}%
  [$it \igobs$ $it_{0}$ $\land$ haySiguiente?($it$)]%pre
  {$it$ $\igobs$ avanzar($it_{0}$)}%pos
  [$\Theta(1)$]%complejidad
  [Avanza el iterador a la siguiente posicion. ]%descripcion
  []%aliasing
  

\end{Interfaz}

\begin{Representacion}

  \Encabezado{Estructura Red}
  
  \begin{Estructura}{Red}[estrRed]

    \begin{Tupla}[estrRed]
      \tupItem{compus}{lista(estrCompu)}
      \tupItem{cantidadCompus}{nat}
    \end{Tupla}

    \begin{Tupla}[estrCompu]
      \tupItem{IP}{string}
      \tupItem{conexiones}{lista(tupla(inter: interfaz, com: itLista(estrCompu)))}
    \end{Tupla}

  \end{Estructura}

  \RepFc[Red][e]{($\forall c$: compu)(c $\in$ ArmarComputadoras(e.compus) $\impluego$ $\lnot$ Pertenece?(e.compus, c, c))$\land$ \\
    $\#$ArmarComputadoras(e.compus) = e.cantCompus $\land$ \\
    ($\forall c_{1}$: compu)(($\forall c_{2}$: compu) ($c_{1}$ $\in$ ArmarComputadoras(e.compus) $\land$ $c_{2}$ $\in$ ArmarComputadoras(e.compus) $\impluego$ Pertenece?(e.compus, $c_{1}$, $c_{2}$) $\Leftrightarrow$ Pertenece?(e.compus, $c_{2}$, $c_{1}$))) $\land$ \\
    ($\forall c_{1}$: compu)($c_{1}$ $\in$ ArmarComputadoras(e.compus) $\impluego$ ($\forall c_{2}$: compu) (Pertenece?(e.compus, $c_{1}$, $c_{2}$) $\Rightarrow$ $c_{2}$ $\in$ ArmarComputadoras(e.compus))) $\land$ \\
    sinRepetidos(ArmarSecuencia(e.compus)) 
    }\mbox{}

  ~

  \AbsFc[estrRed]{Red}[e]{(r: Red | computadoras(r) = ArmarComputadoras(e.compus) $\land$ \\
    ($\forall c_{1}$: compu)(($\forall c_{2}$: compu) conectados?(r, $c_{1}$, $c_{2}$) = Pertenece?(e.compus, $c_{1}$, $c_{2}$) $\land$ \\
    InterfazUsada(r, $c_{1}$, $c_{2}$) = DevolverInterfaz(e.compus, $c_{1}$, $c_{2}$)))
  }
  
   \Encabezado{Estructura iterador de Red}
  
  \begin{Estructura}{itRed}[itLista(estrCompu)]
  \end{Estructura}

  \RepFc[itRed][it]{true}\mbox{}

  ~

  \AbsFc[itRed]{itUni(estrCompu)}[itl]{
    $itr$: itUni(estrCompu)| siguientes($itr$) $\igobs$ armarCompus(siguiente($itl$))
  }

  ~

  \tadOperacion{ArmarComputadoras}{secu(tupla(string{,} secu(tupla(Interfaz{,} ItRed))))}{conj(compu)}{}
  \tadAxioma{ArmarComputadoras($l$)}{\IF vacia?(l) THEN $\emptyset$ ELSE Ag($\langle \pi_{1}$(prim($l$)), GenerarInterfaces($\pi_{2}$(prim($l$)))$\rangle$, ArmarComputadoras(fin($l$))) FI}

  ~
  
  \tadOperacion{ArmarSecuencia}{secu(tupla(string{,} secu(tupla(interfaz{,} itLista(compu)))))}{secu(string)}{}
  \tadAxioma{ArmarSecuencia(s)}{\IF vacia?($s$) THEN <> ELSE ($\pi_{1}$(prim(s))) $\puntito$ ArmarSecuencia(fin($s$)) FI}
  
  \tadOperacion{sinRepetidos}{secu(string)}{bool}{}
  \tadAxioma{sinRepetidos($s$)}{\#(pasarSecuAConj($s$) $=$ long($s$)}
  
  \tadOperacion{pasarSecuAConj}{secu(string)}{conj(string)}{}
  \tadAxioma{pasarSecuAConj($s$)}{\IF vacia?($s$) THEN $\emptyset$ ELSE Ag(prim($s$), pasarSecuAConj(fin($s$))) FI}
  

  \tadOperacion{GenerarInterfaces}{secu(tupla(Interfaz{,} ItLista(estrCompu)))}{conj(Interfaz)}{}
  \tadAxioma{GenerarInterfaces($l$)}{\IF vacia?($l$) THEN $\emptyset$ ELSE Ag($\pi_{1}$(prim($l$)), GenerarInterfaces(fin($l$))) FI}

  ~

  \tadOperacion{Pertenece?}{secu(tupla(string{,} secu(tupla(Interfaz{,} ItRed))))/l, compu/c_{1}, compu/c_{2}}{bool}{}
  \tadAxioma{Pertenece?($l$, $c_{1}$, $c_{2}$)}{\IF ($\pi_{1}$(prim($l$) = $\pi_{1}$($c_{1}$))) THEN $\pi_{1}$($c_{2}$) $\in$ GenerarCompus($\pi_{2}$(prim($l$))) ELSE Pertenece?(fin($l$), $c_{1}$, $c_{2}$) FI}

  ~

  \tadOperacion{GenerarCompus}{secu(tupla<Interfaz, ItLista(estrCompu)>)}{conj(string)}{}
  \tadAxioma{GenerarCompus($l$)}{\IF vacia?($l$) THEN $\emptyset$ ELSE Ag($\pi_{1}$(siguiente($\pi_{2}$(prim($l$)))), GenerarCompus(fin($l$))) FI}

  ~

  \tadOperacion{DevolverInterfaz}{secu(tupla<string, secu(tupla<Interfaz, ItRed>)>)/l, compu/c_{1}, compu/c_{2}}{Interfaz}{Pertenece?($l$, $c_{1}$, $c_{2}$} % Restriccion? Pertenece?(l, c1, c2) o c1 \in computadoras(r)
  \tadAxioma{DevolverInterfaz($l$, $c_{1}$, $c_{2}$)}{\IF ($\pi_{1}$(prim($l$)) = $\pi_{1}$($c_{1}$)) THEN DevolverInterfazAux($\pi_{2}$(prim($l$), $c_{2}$)) ELSE DevolverInterfaz(fin($l$, $c_{1}$, $c_{2}$)) FI}

  ~  
  
   \tadOperacion{DevolverInterfazAux}{secu(tupla<Interfaz, ItRed>)/l, compu/c}{Interfaz}{} % Restriccion? Pertenece?(l, c1, c2) o c1 \in computadoras(r)
  \tadAxioma{DevolverInterfaz($l$, $c$)}{\IF ($\pi_{1}$($c_{2}$) = $\pi_{1}$(siguiente($\pi_{2}$(prim($l$))))) THEN $\pi_{1}$(prim($l$)) ELSE DevolverInterfazAux(fin($l$, c)) FI}

  ~

  \tadOperacion{armarCompus}{secu(estrCompu)/l}{secu(compu)}{}
  \tadAxioma{armarCompus($es$)}{\IF vac\'{i}a(es) THEN <> ELSE armarCompu(prim($es$)) $\bullet$ armarCompus(fin($es$)) FI}

  ~

  \tadOperacion{armarCompu}{estrCompu/e}{compu}{}
  \tadAxioma{armarCompu($e$)}{$\langle e$.IP, dame$\Pi_{1}$($e$.conexiones)$\rangle$}

  ~

  \tadOperacion{dame$\Pi_{1}$}{secu(tupla$\langle inter$: interfaz, $itCompu$: itLista(estrCompu)$\rangle$)/l}{conj(interfaz)}{}
  \tadAxioma{dame$\Pi_{1}$($l$)}{\IF vac\'{i}a($l$) THEN $\emptyset$ ELSE ag($Pi_{1}$(prim($l$)), dame$\Pi_{1}$(fin($l$)))FI}

  ~

\end{Representacion}

\begin{Algoritmos}

  \Encabezado{Algoritmos de Red}
  
  \begin{algoritmo}{iIniciarRed}{}{estrRed}{
    $res \gets \langle$<>, 0$\rangle$ \com*{$\Theta(1)$}
  }
  \end{algoritmo}
   \complejidad{$\Theta(1)$}

  \begin{algoritmo}{iAgregarCompu}{\Inout{r}{estrRed}, \In{c}{compu}}{}
    agregarAtras(r.compus, $\langle$c.IP, iArmarLista(c.interfaces)$\rangle$)\com*{$\Theta(I)$}
    $r.cantidadCompus \gets r.cantidadCompus+1$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \complejidad{$\Theta(I)$}
  
  \begin{algoritmo}{iArmarLista}{\In{c}{conj(interfaz)}}{lista($\langle$Interfaz, itLista(estrCompu)$\rangle$)}
    $res \gets$ vacia()\com*{$\Theta(1)$}
    \tipo{itConj(interfaz)} $it \gets$ crearIt(c)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){haySiguiente($it$)}{
      agregarAtras($res$, $\langle$siguiente($it$), NULL$\rangle$)\com*{$\Theta(1)$}
      avanzar($it$)\com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \complejidad{$\Theta(I)$}
  
  \begin{algoritmo}{iConectar}{\Inout{r}{estrRed)}, \In{c_{1}}{compu}, \In{i_{1}}{interfaz}, \In{c_{2}}{compu}, \In{i_{2}}{interfaz}}{}
    \tipo{itLista(estrComp)} $it_{1} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}
    \tipo{itLista(estrComp)} $it_{2} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_{1}$).IP $\neq$ $c_{1}$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
   \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_{2}$).IP $\neq$ $c_{2}$.IP}{
      avanzar($it_{2}$)\com*{$\Theta(1)$}
    }
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{3} \gets$ crearIt(siguiente($it_{1}$).conexiones))\com*{$\Theta(1)$}
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{4} \gets$ crearIt(siguiente($it_{2}$).conexiones)\com*{$\Theta(1)$}
    
   \While(\com*[f]{$\Theta(I)$ iteraciones}){siguiente($it_{3}$).inter $\neq$ $i_{1}$}{
      avanzar($it_{3}$)\com*{$\Theta(1)$}
    }
   \While(\com*[f]{$\Theta(I)$ iteraciones}){siguiente($it_{4}$).inter $\neq$ $i_{2}$}{
      avanzar($it_{4}$)\com*{$\Theta(1)$}
    }

    siguiente($it_{3$).com $\gets$ $it_{2}$\com*{$\Theta(1)$}
    siguiente($it_{4}$).com $\gets$ $it_{1}$\com*{$\Theta(1)$}
  \end{algoritmo}
  \complejidad{$\Theta(n+I)$}
  
  \begin{algoritmo}{iConectadas?}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{bool}{}
    \tipo{itLista(estrCompu)} $it_{1} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_{1}$).IP $\neq c_{1}$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{2} \gets$ crearIt(siguiente($it_{1}$).conexiones)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){haySiguiente($it_{2}$) $\yluego$ siguiente(siguiente($it_{2}$).com)).IP $\neq c_{2}$.IP}{
      avanzar($it_{2}$)\com*{$\Theta(1)$}
    }
    $res \gets$ (siguiente(siguiente($it_{2}$).com)).IP $= c_{2}$.IP)\com*{$\Theta(1)$}
  \end{algoritmo}  
  \complejidad{$\Theta(n+I)$}

  \begin{algoritmo}{iInterfazUsada}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{interfaz}{}
    \tipo{itLista(estrCompu)} $it_{1} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}  
    \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_{1}$).IP $\neq c_{1}$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{2} \gets$ crearIt(siguiente($it_{1}$).conexiones)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){(siguiente(siguiente($it_{2}$).com)).IP $\neq c_{2}$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
    $res \gets$ siguiente($it_{2}$).inter\com*{$\Theta(1)$}
  \end{algoritmo}  
  \complejidad{$\Theta(n+I)$}
    
  \begin{algoritmo}{iVecinos}{\In{r}{estrRed}, \In{c}{compu}}{conj(compu)}{}
    $res \gets$ vacio() \com*{$\Theta(1)$}
    \tipo{itLista(estrComp)} $it_{1} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_{1}$).IP $\neq c$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{2} \gets$ crearIt(siguiente($it_{1}$).conexiones)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){haySiguiente?($it_{2}$)}{
      \If(\com*[f]{$\Theta(1)$}){haySiguiente?(siguiente($it_{2}$).com)}{
        agregar($res$, $\langle$siguiente(siguiente($it_{2}$).com).IP, crearConjunto(siguiente(siguiente($it_{2}$).com).conexiones))$\rangle$)\com*{$\Theta(I²)$}
      }
      avanzar($it_{2}$)\com*{$\Theta(1)$}
    }
  \end{algoritmo}
   \complejidad{$\Theta(n+I³)$}
  
   \begin{algoritmo}{iCrearConjunto}{\In{l}{lista(tupla(inter: interfaz, com: itLista(estrCompu)))}}{conj(interfaz)}{}
    \tipo{nat} $n \gets$ 0\com*{$\Theta(1)$}
    $res \gets$ vacio()\com*{$\Theta(1)$}
   \While(\com*[f]{$\Theta(I)$ iteraciones}){n < longitud(l)}{
      agregar($res$, (l[n]).inter)\com*{$\Theta(I)$}
      $n \gets n+1$\com*{$\Theta(1)$}
    }
  \end{algoritmo} 
   \complejidad{$\Theta(I²)$}

  \begin{algoritmo}{iUsaInterfaz?}{\In{r}{estrRed}, \In{c}{compu}, \In{i}{interfaz}}{bool}{}
    \tipo{itLista(estrComp)} $it_{1} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}
    \While(\com*{$\Theta(n)$ iteraciones}){siguiente($it_{1}$).IP $\neq c$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
    \tipo{itLista(tupla$\langle$interfaz, itLista(estrCompu)$\rangle$)} $it_{2} \gets$ crearIt(siguiente($it_{1}$).conexiones)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){siguiente($it_{2}$).inter $\neq i$}{
     avanzar($it_{2}$)\com*{$\Theta(1)$}
    }
    $res \gets$ haySiguiente(siguiente($it_{2}$).com)\com*{$\Theta(1)$}
  \end{algoritmo}
   \complejidad{$\Theta(n+I)$}
   
  \begin{algoritmo}{iCaminosMinimos}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{conj(lista(compu))}{}
    $res \gets$ vacio()\com*{$\Theta(1)$}
    \eIf(\com*[f]{$\Theta(I)$}){pertenece?($c_{2}$, vecinos($r$, $c_{1}$))}{
      agregar($res$, agregarAtras(agregarAtras(<>,$c_{1}$), $c_{2}$))\com*{$\Theta(n+I)$}
    }{
      $res \gets$ dameMinimos(Caminos($r$, $c_{1}$, $c_{2}$, agregarAtras(<>,$c_{1}$), pasarConjASecu(vecinos($r$, $c_{1}$))))\;
    }
  \end{algoritmo}
    
	\begin{algoritmo}{pasarConjASecu}{\In{c}{conj(compu)}}{secu(compu)}{}
		$res \gets$ vacia()\com*{$\Theta(1)$}
		\Tipo{ItConj} $it \gets$ crearIt(c)\com*{$\Theta(1)$}
		While(\com*[f]{$\Theta(n)$ iteraciones}{haySiguiente($it$)}{
			agregarAtras($res$, siguiente($it$))\com*{$\Theta(I)$} 		
		}
	\end{algoritmo}    
    \complejidad{$\Theta(n \times I)$}   
     
  \begin{algoritmo}{iHayCamino?}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{bool}{}
    $res \gets$ ($\neg$esVacio?(iCaminosMinimos($r$, $c_{1}$, $c_{2}$)))
  \end{algoritmo}

  \begin{algoritmo}{iCaminos}{\In{r}{estrRed}, \In{c_{0}}{estrCompu}, \In{c_{1}}{estrCompu}, \In{l}{lista(estrCompu)}, \In{vec}{lista(estrCompu)}}{conj(lista(estrCompu))}{}
    \eIf{vacia?($vec$)}{
      $res \gets$ vacia()\;
    }{
      \eIf{/'{u}ltimo($l$) = $c_{1}$}{
        $res \gets$ agregar($l$, vacia())\;
      }{
        \eIf{$\not$est\'{a}?(primero($vec$, $l$))}{
          $res \gets$ uni\'{o}n(caminos($r$, $c_{0}$, $c_{1}$, agregarAtras($l$, primero($vec$)), iVecinos($r$, primeros($vec$))), caminos($r$, $c_{0}$, $c_{1}$, $l$, fin($vec$)))\;
        }{
          $res \gets$ caminos($r$, $c_{0}$, $c_{1}$, $l$, fin($vec$))\;
        }
      }
    }
  \end{algoritmo}
  
  \begin{algoritmo}{iComputadoras}{\In{r}{estrRed}}{conj(compu)}{}
    $res \gets$ vacio()\com*{$\Theta(1)$}
    \tipo{itRed} $it \gets$ crearItRed()\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){haySiguiente?($it$)}{
      agregar($res$, siguiente($it$))\com*{$\Theta(n+I²)$}
      avanzar($it$)\com*{$\Theta(1)$}
    }
  \end{algoritmo}
   \complejidad{$\Theta(n \times (n+I²))$}
   
   \begin{algoritmo}{iCopiar}{\In r:estrRed}{Red}
   	$res \gets$ $\langle$copiar(r.compus, r.cantCompus$\rangle$\com*{$\Theta(n \times I)$}
   \end{algoritmo}
   \complejidad{$\Theta(n \times I)$}    


   \Encabezado{Algoritmos del iterador de Red}

  \begin{algoritmo}{iHaySiguiente?}{\In{it}{itLista(estrCompu)}}{bool}{}
  $res \gets$ haySiguiente?($it$)\com*{$\Theta(1)$}
  \end{algoritmo}
    \complejidad{$\Theta(1)$}  

  \begin{algoritmo}{iSiguiente}{\In{it}{itLista(estrCompu)}}{compu}{}
    \tipo{estrCompu} $e \gets$ siguiente($it$)\com*{$\Theta(1)$}
    $res$.IP $\gets$ $e$.IP\com*{$\Theta(1)$}
    \tipo{conj(interfaz)} $interfaces \gets$ vac\'{i}o()\com*{$\Theta(1)$}
    \tipo{itLista(tupla$\langle$ $inter$: interfaz, $com$: itLista(estrCompu)$\rangle$)} $itInterfaces \gets$ crearIt($e$.conexiones)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){haySiguiente?($itInterfaces$)}{
      agregar($interfaces$, siguiente($itInterfaces$).inter)\com*{$\Theta(I)$}
      avanzar($itInterfaces$)\com*{$\Theta(1)$}
    }
    $res$.Interfaces $\gets$ $e$.Interfaces\com*{$\Theta(I)$}
  \end{algoritmo}
   \complejidad{$\Theta(I²)$}   
    
  \begin{algoritmo}{iCrearIt}{\In{e}{estrRed}}{}
  $res \gets$ crearIt($e$.compus)\com*{$\Theta(1)$}
  \end{algoritmo}
   \complejidad{$\Theta(1)$} 
   
  \begin{algoritmo}{iAvanzar}{\Inout{it}{itLista(estrCompu)}}
  $it \gets$ avanzar($it$)\com*{$\Theta(1)$}
  \end{algoritmo}
   \complejidad{$\Theta(1)$} 
   

\end{Algoritmos}










