\section{M\'{o}dulo Red}

\Encabezado{Notas preliminares}
  En todos los casos, al indicar las complejidades de los algoritmos, las variables que se utilizan corresponden a:
  \vspace{-0.5em}\begin{itemize}
    \item $n$: N\'umero de computadoras en la red.
    \item $L$: Longitud de nombre de computadora m\'as largo de la red.
    \item $I$: Mayor cantidad de interfaces que tiene alguna computadora en la red en el momento.
  \end{itemize}

\servUsados{interfaz, tupla, nat, IP, lista\_enlazada}

\begin{Interfaz}
  
  \seExplicaCon{Red, Iterador Unidireccional(Compu)}

  \generos{\tipo{red}, \tipo{itRed}}
  
  \Encabezado{Operaciones b\'{a}sicas de Red}

  \InterfazFuncion{iniciarRed}{}{Red}%
  {res $\igobs$ iniciarRed()}%pos
  [$\Theta(1)$]%complejidad
  [Genera una nueva red sin ninguna computadora.]%descripcion
  []%aliasing
  
  \InterfazFuncion{agregarCompu}{\Inout{r}{Red}, \In{c}{compu}}{}%
  [$r$ $\igobs$ $r_{0}$ $\land$ ($\forall c'$: compu)($c' \in$ computadoras($r$) $\rightarrow$ ip($c$) $\neq$ ip($c'$))]%pre
  {$r$ $\igobs$ agregarCompu($r_{0}$, c)}%pos
  [$\Theta(I)$]%complejidad
  [Agrega una nueva computadora a la red.]%descripcion
  []%aliasing

  \InterfazFuncion{conectar}{\Inout{r}{Red}, \In{c_0}{compu}, \In{i_0}{interfaz}, \In{c_1}{compu}, \In{i_1}{interfaz}}{Red}%
  [$r$ $\igobs$ $r_{0}$ $\land$ $c_{1} \in$ computadoras($r$) $\land$ $c_{2} \in$ computadoras($r$) $\land$ ip($c_{0} $) $\neq$ ip($c_{1}$) $\land$ $\lnot$conectadas?($r$, $c_{0}$ , $c_{1} $) $\land$ $\lnot$usaInterfaz?($r$, $c_{0}$, $i_{0}$) $\land$ $\lnot$usaInterfaz?($r$, $c_{1}$, $i_{1}$)]%pre
  {$r$ $\igobs$ conectar($r_{0}$, $c_{0}$, $i_{0}$, $c_{1}$, $i_{1}$)}%pos
  [$\Theta(n+I)$]%complejidad
  [Conecta la pc $c_{0}$ con la pc $c_{1}$ a trav\'es de las interfaces $i_{0}$ y $i_{1}$ respectivamente. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{computadoras}{\In{r}{Red}}{conj(compu)}%
  {$res$ $\igobs$ computadoras(r)} %es alias(res,compus(R))             %pos
  [$\Theta(n \times (n+I²))$]%complejidad
  [Devuelve todas las computadoras de la red. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{conectadas?}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{bool}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)]%pre
  {$res$ $\igobs$ conectadas?($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(n+I)$]%complejidad
  [Devuelve true si y solo si la pc $c_{0}$ esta conectada a la pc $c_{1}$]%descripcion
  []%aliasing
  
  \InterfazFuncion{interfazUsada}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{interfaz}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$) $\yluego$ conectadas?($r$, $c_{0}$, $c_{1}$)]%pre
  {$res$ $\igobs$ interfazUsada($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(n+I)$]%complejidad
  [Devuelve la interfaz usada por $c_{0}$ para conectarse a $c_{1}$]%descripcion
  []%aliasing
  
  \InterfazFuncion{vecinos}{\In{r}{Red}, \In{c}{compu}}{conj(compu)}%
  [$c$ $\in$ computadoras($r$)]%pre
  {$res$ $\igobs$ vecinos($r$, $c$)}%pos
  [$\Theta(n+I³)$]%complejidad
  [Devuelve el conjunto de vecinos de la pc $c$]%descripcion
  []%aliasing
  
  \InterfazFuncion{usaInterfaz?}{\In{r}{Red}, \In{c}{compu}, \In{i}{interfaz}}{bool}%
  [$c$ $\in$ computadoras($r$)]%pre
  {$res$ $\igobs$ usaInterfaz?($r$, $c$, $i$)}%pos
  [$\Theta(n+I)$]%complejidad
  [Devuelve true si y solo si la pc $c$ esta usando la interfaz $i$. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{caminosMinimos}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{conj(secu(compu))}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)]%pre
  {$res$ $\igobs$ caminosMinimos($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve todos los caminos m\'nimos posibles entre $c_{0}$ y $c_{1}$. De no haber ninguno, devuelve $\emptyset$. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{hayCamino?}{\In{r}{Red}, \In{c_{0}}{compu}, \In{c_{1}}{compu}}{bool}%
  [$c_{0}$ $\in$ computadoras($r$) $\land$ $c_{1} \in $ computadoras($r$)]%pre
  {$res$ $\igobs$ hayCamino?($r$, $c_{0}$, $c_{1}$)}%pos
  [$\Theta(1234)$]%complejidad
  [Devuelve true si y solo si hay alg\'un camino posible entre $c_{0}$ y $c_{1}$. ]%descripcion
  []%aliasing
  
  \InterfazFuncion{cantCompus}{\In{r}{Red}}{nat}%
  [true]%pre
  {$res$ $\igobs$ \#(computadoras(r))}%pos
  [$\Theta(1)$]%complejidad
  [Devuelve cu\'antas computadoras hay en la red.]%descripcion
  []%aliasing

  \InterfazFuncion{copiar}{\In{r}{Red}}{Red}%
  [true]%pre
  {$res$ $\igobs$ $r$}%pos
  [$\Theta(n \times I)$]%complejidad
  [Devuelve una copia de la red.]%descripcion
  []%aliasing

  \Encabezado{Operaciones b\'{a}sicas del iterador de red}

  \InterfazFuncion{crearIt}{\In{r}{Red}}{itRed}%
  [true]%pre
  {$res$ $\igobs$ crearItUni($r$.compus)}%pos
  [$\Theta(1)$]%complejidad
  [Crea un iterador de red.]%descripcion
  []%aliasing

  \InterfazFuncion{haySiguiente?}{\In{it}{itRed}}{bool}%
  [true]%pre
  {$res$ $\igobs$ hayMas?($it$)}%pos
  [$\Theta(1)$]%complejidad
  [Devuelve true si y solo si $it$ tiene una computadora siguiente.]%descripcion
  []%aliasing

  \InterfazFuncion{siguiente}{\In{it}{itRed}}{compu}%
  [true]%pre
  {$res$ $\igobs$ actual($it$)}%pos
  [$\Theta(I^2)$]%complejidad
  [Devuelve la computadora siguiente a la posici\'on del iterador.]%descripcion
  [$res$ se devuelve por referencia]%aliasing

  \InterfazFuncion{avanzar}{\Inout{it}{itRed}}{}%
  [$it \igobs$ $it_{0}$ $\land$ haySiguiente?($it$)]%pre
  {$it$ $\igobs$ avanzar($it_{0}$)}%pos
  [$\Theta(1)$]%complejidad
  [Avanza el iterador a la siguiente posici\'on.]%descripcion
  []%aliasing
  

\end{Interfaz}

\begin{Representacion}

  \Encabezado{Estructura Red}
  
  \begin{Estructura}{Red}[estrRed]

    \begin{Tupla}[estrRed]
      \tupItem{compus}{lista(estrCompu)}
      \tupItem{cantidadCompus}{nat}
    \end{Tupla}

    \begin{Tupla}[estrCompu]
      \tupItem{IP}{IP}
      \tupItem{conexiones}{lista(tupla(inter: interfaz, com: itLista(estrCompu)))}
    \end{Tupla}

  \end{Estructura}

  \RepFc[Red][e]{($\forall c$: compu)(c $\in$ ArmarComputadoras(e.compus) $\impluego$ $\lnot$ Pertenece?(e.compus, c, c))$\land$ \\
    $\#$ArmarComputadoras(e.compus) = e.cantidadCompus $\land$ \\
    ($\forall c_{1}$: compu)(($\forall c_{2}$: compu) ($c_{1}$ $\in$ ArmarComputadoras(e.compus) $\land$ $c_{2}$ $\in$ ArmarComputadoras(e.compus) $\impluego$ Pertenece?(e.compus, $c_{1}$, $c_{2}$) $\Leftrightarrow$ Pertenece?(e.compus, $c_{2}$, $c_{1}$))) $\land$ \\
    ($\forall c_{1}$: compu)($c_{1}$ $\in$ ArmarComputadoras(e.compus) $\impluego$ ($\forall c_{2}$: compu) (Pertenece?(e.compus, $c_{1}$, $c_{2}$) $\Rightarrow$ $c_{2}$ $\in$ ArmarComputadoras(e.compus))) $\land$ \\
    sinRepetidos(ArmarSecuencia(e.compus)) 
    }\mbox{}

  ~

  \AbsFc[estrRed]{Red}[e]{(r: Red | computadoras(r) = ArmarComputadoras(e.compus) $\land$ \\
    ($\forall c_{1}$: compu)(($\forall c_{2}$: compu) conectados?(r, $c_{1}$, $c_{2}$) = Pertenece?(e.compus, $c_{1}$, $c_{2}$) $\land$ \\
    InterfazUsada(r, $c_{1}$, $c_{2}$) = DevolverInterfaz(e.compus, $c_{1}$, $c_{2}$)))
  }
  
   \Encabezado{Estructura iterador de Red}
  
  \begin{Estructura}{itRed}[itLista(estrCompu)]
  \end{Estructura}

  \RepFc[itRed][it]{true}\mbox{}

  ~

  \AbsFc[itRed]{itUni(estrCompu)}[itl]{
    $itr$: itUni(estrCompu)| siguientes($itr$) $\igobs$ armarCompus(siguiente($itl$))
  }

  ~

  \tadOperacion{ArmarComputadoras}{secu(tupla(string{,} secu(tupla(Interfaz{,} ItRed))))}{conj(compu)}{}
  \tadAxioma{ArmarComputadoras($l$)}{\IF vacia?(l) THEN $\emptyset$ ELSE Ag($\langle \Pi_{1}$(prim($l$)), GenerarInterfaces($\Pi_{2}$(prim($l$)))$\rangle$, ArmarComputadoras(fin($l$))) FI}

  ~
  
  \tadOperacion{ArmarSecuencia}{secu(tupla(string{,} secu(tupla(interfaz{,} itLista(compu)))))}{secu(string)}{}
  \tadAxioma{ArmarSecuencia(s)}{\IF vacia?($s$) THEN <> ELSE ($\Pi_{1}$(prim(s))) $\puntito$ ArmarSecuencia(fin($s$)) FI}
  
  \tadOperacion{sinRepetidos}{secu(string)}{bool}{}
  \tadAxioma{sinRepetidos($s$)}{\#(pasarSecuAConj($s$) $=$ long($s$)}
  
  \tadOperacion{pasarSecuAConj}{secu(string)}{conj(string)}{}
  \tadAxioma{pasarSecuAConj($s$)}{\IF vacia?($s$) THEN $\emptyset$ ELSE Ag(prim($s$), pasarSecuAConj(fin($s$))) FI}
  

  \tadOperacion{GenerarInterfaces}{secu(tupla(Interfaz{,} ItLista(estrCompu)))}{conj(Interfaz)}{}
  \tadAxioma{GenerarInterfaces($l$)}{\IF vacia?($l$) THEN $\emptyset$ ELSE Ag($\Pi_{1}$(prim($l$)), GenerarInterfaces(fin($l$))) FI}

  ~

  \tadOperacion{Pertenece?}{secu(tupla(string{,} secu(tupla(Interfaz{,} ItRed))))/l, compu/c_{1}, compu/c_{2}}{bool}{}
  \tadAxioma{Pertenece?($l$, $c_{1}$, $c_{2}$)}{\IF ($\Pi_{1}$(prim($l$) = $\Pi_{1}$($c_{1}$))) THEN $\Pi_{1}$($c_{2}$) $\in$ GenerarCompus($\Pi_{2}$(prim($l$))) ELSE Pertenece?(fin($l$), $c_{1}$, $c_{2}$) FI}

  ~

  \tadOperacion{GenerarCompus}{secu(tupla<Interfaz, ItLista(estrCompu)>)}{conj(string)}{}
  \tadAxioma{GenerarCompus($l$)}{\IF vacia?($l$) THEN $\emptyset$ ELSE Ag($\Pi_{1}$(siguiente($\Pi_{2}$(prim($l$)))), GenerarCompus(fin($l$))) FI}

  ~

  \tadOperacion{DevolverInterfaz}{secu(tupla(string, secu(tupla(Interfaz, ItRed))))/l, compu/c_{1}, compu/c_{2}}{Interfaz}{Pertenece?($l$, $c_{1}$, $c_{2}$} % Restriccion? Pertenece?(l, c1, c2) o c1 \in computadoras(r)
  \tadAxioma{DevolverInterfaz($l$, $c_{1}$, $c_{2}$)}{\IF ($\Pi_{1}$(prim($l$)) = $\Pi_{1}$($c_{1}$)) THEN DevolverInterfazAux($\Pi_{2}$(prim($l$), $c_{2}$)) ELSE DevolverInterfaz(fin($l$, $c_{1}$, $c_{2}$)) FI}

  ~  
  
  \tadOperacion{DevolverInterfazAux}{secu(tupla(Interfaz, ItRed))/l, compu/c}{Interfaz}{} % Restriccion? Pertenece?(l, c1, c2) o c1 \in computadoras(r)
  \tadAxioma{DevolverInterfaz($l$, $c$)}{\IF ($\Pi_{1}$($c_{2}$) = $\Pi_{1}$(siguiente($\Pi_{2}$(prim($l$))))) THEN $\Pi_{1}$(prim($l$)) ELSE DevolverInterfazAux(fin($l$, c)) FI}

  ~

  \tadOperacion{armarCompus}{secu(estrCompu)/l}{secu(compu)}{}
  \tadAxioma{armarCompus($es$)}{\IF vac\'{i}a(es) THEN <> ELSE armarCompu(prim($es$)) $\bullet$ armarCompus(fin($es$)) FI}

  ~

  \tadOperacion{armarCompu}{estrCompu/e}{compu}{}
  \tadAxioma{armarCompu($e$)}{$\langle e$.IP, dame$\Pi_{1}$($e$.conexiones)$\rangle$}

  ~

  \tadOperacion{dame$\Pi_{1}$}{secu(tupla($inter$: interfaz, $itCompu$: itLista(estrCompu)))/l}{conj(interfaz)}{}
  \tadAxioma{dame$\Pi_{1}$($l$)}{\IF vac\'{i}a($l$) THEN $\emptyset$ ELSE ag($Pi_{1}$(prim($l$)), dame$\Pi_{1}$(fin($l$)))FI}

  ~

\end{Representacion}

\begin{Algoritmos}

  \Encabezado{Algoritmos de Red}
  
  \begin{algoritmo}{iIniciarRed}{}{estrRed}
    $res \gets \langle$<>, 0$\rangle$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{iAgregarCompu}{\Inout{r}{estrRed}, \In{c}{compu}}{}
    agregarAtras(r.compus, $\langle$c.IP, iArmarLista(c.interfaces)$\rangle$)\com*{$\Theta(I)$}
    $r.cantidadCompus \gets r.cantidadCompus+1$ \com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(I)$} % Complejidad
  {} % Justificacíón
  
  \begin{algoritmo}{iArmarLista}{\In{c}{conj(interfaz)}}{lista($\langle$Interfaz, itLista(estrCompu)$\rangle$)}
    $res \gets$ vacia()\com*{$\Theta(1)$}
    \tipo{itConj(interfaz)} $it \gets$ crearIt(c)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){haySiguiente($it$)}{
      agregarAtras($res$, $\langle$siguiente($it$), NULL$\rangle$)\com*{$\Theta(1)$}
      avanzar($it$)\com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{Dado un conjunto de interfaces, arma una lista, que representa las computadoras sin conexiones como tuplas de Interfaz e Iterador a NULL (ya que cuando una computadora se agrega a la red no est\'{a} conectada a ninguna otra)} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(I)$} % Complejidad
  {} % Justificacíón
  
  \begin{algoritmo}{iConectar}{\Inout{r}{estrRed)}, \In{c_{1}}{compu}, \In{i_{1}}{interfaz}, \In{c_{2}}{compu}, \In{i_{2}}{interfaz}}{}
    \tipo{itLista(estrComp)} $it_{1} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}
    \tipo{itLista(estrComp)} $it_{2} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_{1}$).IP $\neq$ $c_{1}$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
    \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_{2}$).IP $\neq$ $c_{2}$.IP}{
      avanzar($it_{2}$)\com*{$\Theta(1)$}
    }
    \tipo{itLista(tupla(interfaz, itLista(estrCompu)))} $it_{3} \gets$ crearIt(siguiente($it_{1}$).conexiones))\com*{$\Theta(1)$}
    \tipo{itLista(tupla(interfaz, itLista(estrCompu)))} $it_{4} \gets$ crearIt(siguiente($it_{2}$).conexiones)\com*{$\Theta(1)$}
    
    \While(\com*[f]{$\Theta(I)$ iteraciones}){siguiente($it_{3}$).inter $\neq$ $i_{1}$}{
      avanzar($it_{3}$)\com*{$\Theta(1)$}
    }
    \While(\com*[f]{$\Theta(I)$ iteraciones}){siguiente($it_{4}$).inter $\neq$ $i_{2}$}{
      avanzar($it_{4}$)\com*{$\Theta(1)$}
    }

    siguiente($it_{3}$).com $\gets$ $it_{2}$\com*{$\Theta(1)$}
    siguiente($it_{4}$).com $\gets$ $it_{1}$\com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n+I)$} % Complejidad
  {} % Justificacíón
  
  
  \begin{algoritmo}{iConectadas?}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{bool}{}
    \tipo{itLista(estrCompu)} $it_{1} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_{1}$).IP $\neq c_{1}$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
    \tipo{itLista(tupla(interfaz, itLista(estrCompu)))} $it_{2} \gets$ crearIt(siguiente($it_{1}$).conexiones)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){haySiguiente($it_{2}$) $\yluego$ siguiente(siguiente($it_{2}$).com)).IP $\neq c_{2}$.IP}{
      avanzar($it_{2}$)\com*{$\Theta(1)$}
    }
    $res \gets$ (siguiente(siguiente($it_{2}$).com)).IP $= c_{2}$.IP)\com*{$\Theta(1)$}
  \end{algoritmo}  
 \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n+I)$} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{iInterfazUsada}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{interfaz}{}
    \tipo{itLista(estrCompu)} $it_{1} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}  
    \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_{1}$).IP $\neq c_{1}$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
    \tipo{itLista(tupla(interfaz, itLista(estrCompu)))} $it_{2} \gets$ crearIt(siguiente($it_{1}$).conexiones)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){(siguiente(siguiente($it_{2}$).com)).IP $\neq c_{2}$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
    $res \gets$ siguiente($it_{2}$).inter\com*{$\Theta(1)$}
  \end{algoritmo}  
 \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n+I)$} % Complejidad
  {} % Justificacíón
    
  \begin{algoritmo}{iVecinos}{\In{r}{estrRed}, \In{c}{compu}}{conj(compu)}{}
    $res \gets$ vacio() \com*{$\Theta(1)$}
    \tipo{itLista(estrComp)} $it_{1} \gets$ crearIt(r.compus) \com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){siguiente($it_{1}$).IP $\neq c$.IP}{
      avanzar($it_{1}$) \com*{$\Theta(1)$}
    }
    \tipo{itLista(tupla(interfaz, itLista(estrCompu)))} $it_{2} \gets$ crearIt(siguiente($it_{1}$).conexiones) \com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){haySiguiente?($it_{2}$)}{
      \If(\com*[f]{$\Theta(1)$}){haySiguiente?(siguiente($it_{2}$).com)}{
        agregar($res$, $\langle$siguiente(siguiente($it_{2}$).com).IP, crearConjunto(siguiente(siguiente($it_{2}$).com).conexiones))$\rangle$)\com*{$\Theta(I^2)$}
      }
      avanzar($it_{2}$)\com*{$\Theta(1)$}
    }
  \end{algoritmo}
   \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n+I³)$} % Complejidad
  {} % Justificacíón
  
   \begin{algoritmo}{iCrearConjunto}{\In{l}{lista(tupla($inter$: interfaz, $com$: itLista(estrCompu)))}}{conj(interfaz)}{}
    \tipo{nat} $n \gets$ 0\com*{$\Theta(1)$}
    $res \gets$ vacio()\com*{$\Theta(1)$}
   \While(\com*[f]{$\Theta(I)$ iteraciones}){n < longitud(l)}{
      agregar($res$, (l[n]).inter)\com*{$\Theta(I)$}
      $n \gets n+1$\com*{$\Theta(1)$}
    }
  \end{algoritmo} 
 \datosAlgoritmo{Dada una lista de tupla de $\langle$Interfaz,Iterador$\rangle$ (que representa las conexiones de la computadora), devuelve el conjunto de todas las interfaces que se encuentran en ella. } % Descripción
  {} % Pre
  {} % Post
  {$\Theta(I²)$} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{iUsaInterfaz?}{\In{r}{estrRed}, \In{c}{compu}, \In{i}{interfaz}}{bool}{}
    \tipo{itLista(estrComp)} $it_{1} \gets$ crearIt(r.compus)\com*{$\Theta(1)$}
    \While(\com*{$\Theta(n)$ iteraciones}){siguiente($it_{1}$).IP $\neq c$.IP}{
      avanzar($it_{1}$)\com*{$\Theta(1)$}
    }
    \tipo{itLista(tupla(interfaz, itLista(estrCompu)))} $it_{2} \gets$ crearIt(siguiente($it_{1}$).conexiones)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){siguiente($it_{2}$).inter $\neq i$}{
     avanzar($it_{2}$)\com*{$\Theta(1)$}
    }
    $res \gets$ haySiguiente(siguiente($it_{2}$).com)\com*{$\Theta(1)$}
  \end{algoritmo} \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n+I)$} % Complejidad
  {} % Justificacíón
   
  \begin{algoritmo}{iCaminosMinimos}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{conj(lista(compu))}{}
    $res \gets$ vacio()\com*{$\Theta(1)$}
    \eIf(\com*[f]{$\Theta(I)$}){pertenece?($c_{2}$, vecinos($r$, $c_{1}$))}{
      agregar($res$, agregarAtras(agregarAtras(<>,$c_{1}$), $c_{2}$))\com*{$\Theta(n+I)$}
    }{
      $res \gets$ dameMinimos(Caminos($r$, $c_{1}$, $c_{2}$, agregarAtras(<>,$c_{1}$), pasarConjASecu(vecinos($r$, $c_{1}$))))\;
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{dameMinimos}{\In{c}{conj(lista(compu))}}{conj(lista(compu))}
    \eIf(\com*[f]{$\Theta(1)$}){esVacio?($c$)}{
      $res \gets$ vacio()\com*{$\Theta(1)$}
    }{
      \tipo{itConj(lista(compu))} $it \gets$ crearIt(c)\com*{$\Theta(1)$}
      $res \gets$ dameMinimosAux($c$, minimaLong($c$, long(siguiente($it$))))\com*{$\Theta(n \times n!)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {\com*{$\Theta(n \times n!)$}} % Complejidad
  {Devuelve, del total de caminos posibles, solo los de longitud m\'{i}nima} % Justificacíón

  \begin{algoritmo}{dameMinimosAux}{\In{c}{conj(lista(compu))}, \In{n}{nat}}{conj(lista(compu))}
    \tipo{itConj(lista(compu))} $it \gets$ crearIt($c$)\com*{$\Theta(1)$}
    $res \gets$ vacio()\;\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n!)$ iteraciones}){haySiguiente($it$)}{
      \eIf(\com*[f]{$\Theta(1)$}){long(siguiente($it$))$=n$}{
        agregar($res$, siguiente($it$))\com*{$\Theta(n)$}
        avanzar($it$) \com*{$\Theta(1)$}
      }{
        avanzar($it$) \com*{$\Theta(1)$}
      }
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {\com*{$\Theta(n \times n!)$}} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{minimaLong}{\In{c}{conj(lista(compu))}, \In{n}{nat}}{nat}
    \tipo{nat} $i \gets n$\com*{$\Theta(1)$}
    \tipo{itConj(lista(compu))} $it \gets$ crearIt($c$)\com*{$\Theta(1)$}
    \While{haySiguiente($it$)}{
      \eIf{long(siguiente($it$))}{
        $i \gets$ longitud(siguiente($it$))\com*{$\Theta(1)$}
        avanzar($it$)\com*{$\Theta(1)$}
      }{
        avanzar($it$)\com*{$\Theta(1)$}
      }
    }
    $res \gets i$\com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {\com*{$\Theta(n!)$}} % Complejidad
  {Devuelve la longitud de la secuencia m\'{a}s chica} % Justificacíón
    
	\begin{algoritmo}{pasarConjASecu}{\In{c}{conj(compu)}}{secu(compu)}{}
		$res \gets$ vacia()\com*{$\Theta(1)$}
		\tipo{ItConj} $it \gets$ crearIt(c)\com*{$\Theta(1)$}
		While(\com*[f]{$\Theta(n)$ iteraciones}{haySiguiente($it$)}{
			agregarAtras($res$, siguiente($it$))\com*{$\Theta(I)$} 		
		}
	\end{algoritmo}    
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n \times I)$} % Complejidad
  {Devuelve una secuencia que contiene a todos los elementos del conjunto pasado por par\'{a}metro} % Justificacíón
     
  \begin{algoritmo}{iHayCamino?}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}}{bool}{}
    $res \gets$ ($\neg$esVacio?(iCaminosMinimos($r$, $c_{1}$, $c_{2}$)))
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{iCaminos}{\In{r}{estrRed}, \In{c_{1}}{compu}, \In{c_{2}}{compu}, \In{l}{lista(estrCompu)}, \In{vec}{lista(estrCompu)}}{conj(lista(estrCompu))}{}
    \eIf{vacia?($vec$)}{
      $res \gets$ vacia()\;
    }{
      \eIf{/'{u}ltimo($l$) = $c_{1}$}{
        $res \gets$ agregar($l$, vacia())\;
      }{
        \eIf{$\not$est\'{a}?(primero($vec$, $l$))}{
          $res \gets$ uni\'{o}n(caminos($r$, $c_{0}$, $c_{1}$, agregarAtras($l$, primero($vec$)), iVecinos($r$, primeros($vec$))), caminos($r$, $c_{0}$, $c_{1}$, $l$, fin($vec$)))\;
        }{
          $res \gets$ caminos($r$, $c_{0}$, $c_{1}$, $l$, fin($vec$))\;
        }
      }
    }
  \end{algoritmo}
  \datosAlgoritmo{Dada una red, dos compus, los vecinos de la primer compu, y una lista que usamos para guardar las computadoras por las que ya preguntamos, iteramos sobre todas las computadoras y devolvemos el conjunto de todos los caminos posibles desde la primer computadora hasta la segunda. } % Descripción
  {} % Pre
  {} % Post
  {} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{iUni\'{o}n}{\In{c_{1}}{conj(lista(compu))}, \In{c_{2}}{conj(lista(compu))}}{conj(lista(compu))}
    $res \gets$ vacio()\com*{$\Theta(1)$}     
    \eIf(\com*[f]{$\Theta(1)$}){vacio?($c_{1}$)}{
      $res \gets$ $c_{2}$\com*{$\Theta(I \times n \times n!)$} 
      }{
      \tipo{itConj(lista(compu))} $it \gets$ crearIt($c_{1}$)\com*{$\Theta(1)$}     
      \While(\com[f]*{$\Theta(n)$}){haySiguiente($it$)}{
        Ag(siguiente($it$), $c_{2}$)\com*{$\Theta(n)$}
        avanzar(it)\com*{$\Theta(1)$}
      } 
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n² + n \times I \times n!)$} % Complejidad
  {Devuelve la uni\'{o}n de dos conjuntos. } % Justificacíón

  \begin{algoritmo}{iEsta?}{\In{c}{compu}, \In{l}{lista(compu)}}{bool}
    \eIf(\com*{$\Theta(1)$}){vacia?($l$)}{
      $res \gets$ false\com*{$\Theta(1)$}
    }{
    \tipo{ItLista(compu)} $it \gets$ crearIt($l$)\com*{$\Theta(1)$}
      \While(\com*{$\Theta(n)$}){haySiguiente($it$) $\yluego$ siguiente($it$) $\neq$ $c$}{
        avanzar(it)\com*{$\Theta(1)$}
      }
    }
    $res \gets$ (haySiguiente($it$))\com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{Devuelve True si y solo si la compu $c$ se encuentra en la lista l} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n)$} % Complejidad
  {.} % Justificacíón

  \begin{algoritmo}{iComputadoras}{\In{r}{estrRed}}{conj(compu)}{}
    $res \gets$ vacio()\com*{$\Theta(1)$}
    \tipo{itRed} $it \gets$ crearItRed()\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(n)$ iteraciones}){haySiguiente?($it$)}{
      agregar($res$, siguiente($it$))\com*{$\Theta(n+I²)$}
      avanzar($it$)\com*{$\Theta(1)$}
    }
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n \times (n+I²))$} % Complejidad
  {} % Justificacíón
   
   \begin{algoritmo}{iCopiar}{\In r:estrRed}{Red}
   	$res \gets$ $\langle$copiar(r.compus, r.cantidadCompus$\rangle$\com*{$\Theta(n \times I)$}
   \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(n \times I)$} % Complejidad
  {Devuelve una copia de la Red} % Justificacíón

   \begin{algoritmo}{iCantCompus}{\In{r}{Red}}{nat}
    $res \gets$ $r$.cantCompus\com*{$\Theta(1)$}
   \end{algoritmo}   
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificacíón

  \Encabezado{Algoritmos del iterador de Red}

  \begin{algoritmo}{iHaySiguiente?}{\In{it}{itLista(estrCompu)}}{bool}{}
  $res \gets$ haySiguiente?($it$)\com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificacíón

  \begin{algoritmo}{iSiguiente}{\In{it}{itLista(estrCompu)}}{compu}{}
    \tipo{estrCompu} $e \gets$ siguiente($it$)\com*{$\Theta(1)$}
    $res$.IP $\gets$ $e$.IP\com*{$\Theta(1)$}
    \tipo{conj(interfaz)} $interfaces \gets$ vac\'{i}o()\com*{$\Theta(1)$}
    \tipo{itLista(tupla($inter$: interfaz, $com$: itLista(estrCompu)))} $itInterfaces \gets$ crearIt($e$.conexiones)\com*{$\Theta(1)$}
    \While(\com*[f]{$\Theta(I)$ iteraciones}){haySiguiente?($itInterfaces$)}{
      agregar($interfaces$, siguiente($itInterfaces$).inter)\com*{$\Theta(I)$}
      avanzar($itInterfaces$)\com*{$\Theta(1)$}
    }
    $res$.Interfaces $\gets$ $e$.interfaces\com*{$\Theta(I)$}
  \end{algoritmo}
    \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(I^{2})$} % Complejidad
  {} % Justificacíón   
    
  \begin{algoritmo}{iCrearIt}{\In{e}{estrRed}}{}
  $res \gets$ crearIt($e$.compus)\com*{$\Theta(1)$}
  \end{algoritmo}
      \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificacíón  
   
  \begin{algoritmo}{iAvanzar}{\Inout{it}{itLista(estrCompu)}}{}
  $it \gets$ avanzar($it$)\com*{$\Theta(1)$}
  \end{algoritmo}
  \datosAlgoritmo{} % Descripción
  {} % Pre
  {} % Post
  {$\Theta(1)$} % Complejidad
  {} % Justificacíón  

\end{Algoritmos}
